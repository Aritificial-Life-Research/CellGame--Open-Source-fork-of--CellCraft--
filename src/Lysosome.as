package  {	import com.cheezeworld.math.Vector2D;	import flash.geom.ColorTransform;	import flash.geom.Point;	import flash.events.Event;		/**	 * ...	 * @author Lars A. Doucet	 */	public class Lysosome extends BasicUnit	{		//public var isBusy:Boolean = false;		private var busyBit:int = 0;		private var eat_target:Selectable;		private var recycleSelfOnEat:Boolean = false;		public var fuse_target:BigVesicle;		public var fusing:Boolean = false;				public var amEating:Boolean = false;				private var p_bigVesicle:BigVesicle;				public static const PH_BALANCE:Number = 4.5;		public static const VOL_X:Number = 500; //effective volume mult when doing ph stuff with the cytosol		public static const VOL_V:Number = 25; //effective volume mult when doing ph stuff with big vesicles		public static const L_RADIUS:Number = 10;		public static const LYSO_VOL:Number = Math.PI * L_RADIUS * L_RADIUS;				public function Lysosome() 		{			text_title = "Lysosome";			text_description = "A small vesicle filled with digestive acid. Digests stuff and regulates pH";			text_id = "lysosome";			bestColors = [1, 1, 0];			num_id = Selectable.LYSOSOME;			list_actions = Vector.<int>([Act.MOVE, Act.RECYCLE]);			setMaxHealth(3, true);			speed = 5;			init();			makeGameDataObject();			doesCollide = true;			snapToObject = false; //KEEPS EM IN THE MEMBRANE!			does_recycle = true;		}				protected override function autoRadius() {			setRadius(L_RADIUS);		}				public override function doAction(i:int, params:Object=null):Boolean {			switch(i) {				case Act.POP: return doPop(); break;			}			return super.doAction(i, params);		}				private function doPop() {			playAnim("pop");		}				public override function onAnimFinish(i:int,stop:Boolean=true) {			super.onAnimFinish(i,stop);			switch(i) {				case ANIM_GROW: finishGrow();  break;				case ANIM_DIGEST_START: eatTheTarget();  break;				case ANIM_DIGEST: finishDigest();  break;				case ANIM_POP: finishPop(); break;				case ANIM_FUSE: finishFuse(); break;				case ANIM_BUD: finishBud(); break;				default: break;			}		}				public function setBigVesicleFuser(b:BigVesicle) {			p_bigVesicle = b;		}				private function finishPop() {			p_cell.onPopLysosome(this);			//p_cell.onRecycle(this);		}		public function bud() {			makeBusy();			playAnim("bud");		}				public function grow() {			makeBusy();			playAnim("grow");		}				public function finishBud() {			//trace("Lysosome.finishBud() RELEASE");			release();			finishGrow();			if(p_bigVesicle){				p_bigVesicle.onLysosomeBud();				p_bigVesicle = null;			}			rotation = 0;		}				public function deployNucleus(instant:Boolean = false) {			//trace("SlicerEnzyme.slicerDeploy(" + instant + ")");			if(p_cell){				deployCytoplasm(p_cell.c_nucleus.x,p_cell.c_nucleus.y,170,35,true,instant);			}		}				public function deployGolgi(instant:Boolean = false) {			var p:Point = p_cell.getGolgiLoc(); 			deployCytoplasm(p.x, p.y, 50, 10,true,instant); 		}				public function finishGrow() {			release();			deployGolgi();		}				protected override function doMoveToGobj(e:Event) {			super.doMoveToGobj(e);			if (eat_target) {				var dx:Number = x - eat_target.x;				var dy:Number = y - eat_target.y;				var dist2:Number = (dx * dx) + (dy * dy);				if (dist2 <= getRadius2()*2) {					arriveObject();				}			}else {							}					}				public function getCircleVolumeV():Number {			return getCircleVolume() * VOL_V;		}				public function getCircleVolumeX():Number {			return getCircleVolume() * VOL_X;		}							public function finishDigest() {			amEating = false;			//trace("Lysosome.finishDigest() this = " + this.name + " RELEASE");			release();			rotation = 0;  //return to normal			if (recycleSelfOnEat) {				recycleSelfOnEat = false;				p_cell.startRecycle(this);				//super.);			}		}				public function eatTheTarget() {			if (eat_target) {				eat_target.onDeath();				eat_target = null;			}else {				//trace("Lysosome.eatTheTarget() NO TARGET RELEASE");				release();			}		}				public override function cancelMove() {			if (eat_target) {				//trace("LYsosome.cancelMove() RELEASE");				release();			}			super.cancelMove();		}				public function dontFuseWithBigVesicle() {			//trace("Lysosome.dontFuseWithBigVesicle()");			if (!fusing) {								release();				fuse_target = null; //do this before cancel move to avoid bugzes!				cancelMove();				deployGolgi();			}									fuse_target = null;		}				public function fuseWithBigVesicle(b:BigVesicle) {			if (b) {				var v:Vector2D = new Vector2D(x - b.x, y - b.y);				rotation = v.toRotation() * 180 / Math.PI;				rotation -= 90;				moveToObject(b, EDGE,true);				fuse_target = b;				makeBusy();				return true;			}			return false;		}				public function eatSomething(s:Selectable):Boolean {			if (s && !isBusy) {				//trace("Lysosome(" + this.name + ").eatSomething(" + s.name + ")");								if (eat_target != null) {					if (eat_target != s) {												eat_target.releaseFromLysosome(this);					}				}								s.targetForEating(this);				var v:Vector2D = new Vector2D(x - s.x, y - s.y);				rotation = v.toRotation() * 180 / Math.PI; //turn to face it so the engulf animation looks right				rotation -= 90;							   //offset to make it work								moveToObject(s, FLOAT,true);				if(eat_target == null){					eat_target = s;				}else {					//trace("Lysosome.eatSomething(" + s + ")! TArget Already exitsts : " + eat_target);				}				p_cell.onTopOf(CellObject(eat_target), CellObject(this),true);				makeBusy();								return true;			}			return false;		}				public override function tryRecycle(oneOfMany:Boolean=false):Boolean {			if(!isBusy){				return super.tryRecycle(oneOfMany);			}else {				recycleSelfOnEat = true;				return false;			}		}			public function releaseByVirus(v:Virus) {			if (eat_target == v) {				//trace("Lysosome("+this.name+".releaseByVirus("+v.name+") RELEASE");				release();			}		}				public function release() {			if (eat_target) {				eat_target = null;			}			isBusy = false;			if (isMoving) {				cancelMove();			}			deployNucleus();						/*busyBit = 0;			var c:ColorTransform = this.transform.colorTransform;			c.redMultiplier = 1;			c.greenMultiplier = 1;			c.blueMultiplier = 1;			c.redOffset = 0;			c.greenOffset = 0;			c.blueOffset = 0;			this.transform.colorTransform = c;*/		}				private function makeBusy() {						isBusy = true;						/*var c:ColorTransform = this.transform.colorTransform;						if (busyBit == 0) { 				c.redMultiplier = -1;				c.greenMultiplier = -1;				c.blueMultiplier = -1;				c.redOffset = 255;				c.greenOffset = 255;				c.blueOffset = 255;				busyBit = 1; 			}			else { 				c.redMultiplier = -1;				c.greenMultiplier = 1;				c.blueMultiplier = -1;				c.redOffset = 255;				c.greenOffset = 0;				c.blueOffset = 255;				busyBit = 0;			}						this.transform.colorTransform = c;*/		}				protected override function onArriveObj() {			super.onArriveObj();			var proceed:Boolean = false;			if (eat_target) { //hack to avoid bugs				eat_target.x = x;				eat_target.y = y;				if(!eat_target.isDoomed && !eat_target.dying){					amEating = true;					playAnim("digest");					if (eat_target is Virus) {						Virus(eat_target).dismissAllLysosExcept(this);					}					eat_target.startGetEaten();					//eat_target.getEaten();				}			}else if (fuse_target) {				playAnim("fuse");				fusing = true;			}else {				release();			}		}				protected function finishFuse() {			if(fuse_target){				fuse_target.getLysosomeFuse(this);				p_cell.onRecycle(this, false);			}else {				release();				deployGolgi();				//don't do that				//bud();			}									//p_cell.onRecycle(this);		}				protected override function takePHDamage(r:RunFrameEvent) {			//donothing, lysosomes are immune to acid!		}				public override function updateLoc() {			var xx:Number = x-cent_x + span_w / 2;			var yy:Number = y-cent_y + span_h / 2;						updateGridLoc(xx, yy);		}			}	}