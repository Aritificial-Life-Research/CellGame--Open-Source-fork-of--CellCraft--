package  {	import com.cheezeworld.math.Vector2D;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.geom.Point;	import fl.motion.Color;	import flash.utils.Timer;		/**	 * ...	 * @author Lars A. Doucet	 */	public final class MembraneNode implements IGameObject	{		public var x:Number = 0;		public var y:Number = 0;		public var old_x:Number = 0;		public var old_y:Number = 0;		public var rotation:Number = 0;		public var index:int = 0;				public var dying:Boolean = false;				//public var c_bubble:Sprite;				public var p_membrane:Membrane;				public static var CLOSE_ENOUGH:Number = 15;		public static var NODE_PULL:Number = 15;				public static var NODE_PUSH:Number = 6;		public static var CENT_PULL_DIMINISHED:Boolean = false;		public static var CENT_PULL:Number = 10;		public static var CENT_PULL_BASE:Number = 10;		public static const GRAV_PULL:Number = 2;				public static var FRICT:Number = 0.5;		public static const GRAVITY:Number = 40000;				public var stable:Boolean = false;		public var state_ppod:Boolean = false; //are we pseudopoding?		//public var state_bleb:Boolean = false; //are we blebbing?		//public var state_blebcontract:Boolean = false; //are we contracting from blebbing?		public var hasRNA:Boolean = false;		public var list_rna:Vector.<RNA>;				//public var level_bleb:int = -1;		//public var level_ppod:int = -1;				public var state_tube:Boolean = false; //do we care about tubes?				public var p_prev:MembraneNode;		public var p_next:MembraneNode;		public var p_cent:Centrosome;				public var pt_control_next:Point;		public var pt_control_prev:Point;		public var controlSign:int = 1;				public var u_norm:Vector2D; //unit vector, my normal				public var u_next:Vector2D; //unit vector in dir of next node		public var u_prev:Vector2D; //unit vector in dir of prev node		public var u_cent:Vector2D; //unit vector in dir of centrosome		public var u_tube:Vector2D; //unit vector in dir of tube		public var u_grav:Vector2D; //unit vector in dir of gravity				public var v_push:Vector2D; //the final push vector once all calcs have been done		public var v_next:Vector2D;		public var v_prev:Vector2D;		public var v_cent:Vector2D; //final centrosome pull		public var v_tube:Vector2D; //final tube pull 		public var v_grav:Vector2D; //final gravity pull				public var dpull_node:Number = 0;		public var dpull_cent:Number = 0;		public var dpull_tube:Number = 0;		public var dpull_next:Number = 0;		public var dpull_prev:Number = 0;				//public const power_ppod:Number = 5;		//public const power_bleb:Number = 30;				public var f_node:Vector2D;	//forces		public var f_cent:Vector2D;		/*public var f_ppod:Vector2D;		public var f_bleb:Vector2D;				public   var pull_bleb:Number = 0;		public static var BLEB_FRICT:Number = 0.05;		public static var PPOD_FRICT:Number = 0.3;		public   var pull_ppod:Number = 0;		public static var frict_ppod:Number = 0.1;*/		//public   var frict_bleb:Number = 0.01;				public var foldRatio:Number = 1;		public var d2_next:Number; //distance^2 to p_next		public var d2_cent:Number = 1;				private var d_centx:Number = 0;		private var d_centy:Number = 0;				public static var D2_CENT:Number = 1; //the GREATEST D2_CENT that anyone has		public static var D2_CENT_NEW:Number = 1; //for the next update				public var rest_node:Boolean = false;		public var rest_cent:Boolean = false;		public var rest_tube:Boolean = false;				public static var D_NODEREST:Number;		public static var D_CENTREST:Number;				public static var D2_NODEREST:Number; //distance^2 between nodes that I will rest at		public static var D2_NODEREST_OLD:Number;		public static var D2_CENTREST:Number;				/*public static var BLEB_CONTRACT_MULT:Number = 0.1;		public static var BLEB_MULT:Number = 2;		public static var PPOD_MULT:Number = 2;		public static const BLEB_TIME:int = 100;*/				public var d2_tubeRest:Number;		public var p_org:CellObject;				public var has_collided:Boolean = false;				public var stretch:Number;		//public var count_bleb:int;						private static var NODE_RADIUS:Number = 50;				public var grid_x:Number = 0;		public var grid_y:Number = 0;				public var isFolded:Boolean = false;				private static var span_w:Number = 0;		private static var span_h:Number = 0;		private static var grid_w:Number = 0;		private static var grid_h:Number = 0;		private static var p_grid:ObjectGrid;				private var gdata:GameDataObject; 				//a static variable across the class, whenever the node tugs on the centrosome, the centrosome must move		//to preserve Newton's law of reaction. We build up this "tug" in a static variable, and then the membrane		//uses it to move the whole cell once a frame		public static var tug_x:Number = 0; 		public static var tug_y:Number = 0;				public var tug_prev_x:Number = 0;		public var tug_prev_y:Number = 0;		public var tug_next_x:Number = 0;		public var tug_next_y:Number = 0;				public var xdist:Number = 0; //the distance I moved last		public var ydist:Number = 0;				public function MembraneNode() 		{			u_norm = new Vector2D();			u_cent = new Vector2D();			u_tube = new Vector2D();			u_grav = new Vector2D();						u_next = new Vector2D();			u_prev = new Vector2D();						v_next = new Vector2D();			v_prev = new Vector2D();						v_push = new Vector2D();						v_cent = new Vector2D();			v_grav = new Vector2D();			v_tube = new Vector2D();						f_node = new Vector2D();			f_cent = new Vector2D();			/*f_bleb = new Vector2D();			f_ppod = new Vector2D();*/						pt_control_next = new Point(x, y);			pt_control_prev = new Point(x, y);								}				include "inc_fastmath.as";				public function init() {			makeGameDataObject();			placeInGrid();		}				public static function turnOffCentPull() {			if(!CENT_PULL_DIMINISHED){				CENT_PULL_BASE = CENT_PULL;				CENT_PULL = 0;				CENT_PULL_DIMINISHED = true;			}		}				public static function turnOnCentPull() {			if(CENT_PULL_DIMINISHED){				CENT_PULL = CENT_PULL_BASE;				CENT_PULL_DIMINISHED = false;			}		}				public function getRadius2():Number {			return NODE_RADIUS * NODE_RADIUS;		}				public function destruct() {			p_cent = null;			p_membrane = null;			p_next = null;			p_prev = null;			p_org = null;					}				public function addRNA(r:RNA) {			if (list_rna) {							}else {				list_rna = new Vector.<RNA>();				hasRNA = true;			}			list_rna.push(r);		}				public function removeRNA(r:RNA) {			var length:int = list_rna.length;			for (var i:int = 0; i < length; i++) {				if (list_rna[i] == r) {					list_rna[i] = null;					list_rna.splice(i, 1);					i--;					length--;				}			}			if (length <= 0) {				list_rna = null;				hasRNA = false;			}		}				public static function setGrid(g:ObjectGrid){			grid_w = g.getCellW();			grid_h = g.getCellH();			span_w = g.getSpanW();			span_h = g.getSpanH();			p_grid = g;		}				public function updateStretch() {			stretch = (D2_NODEREST) / d2_next;		}				public function getThick(t:Number):Number{			//fadupinator			//return t;						var thick:Number = stretch;			thick *= t;			if (thick > t) return t;			if (thick < .1) return .1;			return thick;		}				public static function getSprings(nd:Number, cd:Number) {			D2_NODEREST = nd*nd;			D2_CENTREST = cd*cd;			D_NODEREST = nd;			D_CENTREST = cd;					}				public function getColor() {			//return 0x00066FF;			var frac:Number = (D2_NODEREST) / d2_next;			if (frac > 1) frac = 1;			if (frac < 0) frac = 0;						//fadupinator			//frac = 1;						return Color.interpolateColor(0xFF0000, 0x00066FF, frac);		}				public function makeGameDataObject() {			gdata = new GameDataObject();			gdata.setThing(x, y, NODE_RADIUS,this, MembraneNode);		}				public function getGameDataObject():GameDataObject {			return gdata;		}				public function makeSprings() {			/*var distX:Number = x - p_next.x;			var distY:Number = y - p_next.y;			D2_NODEREST = (distX * distX + distY * distY);			distX = x - p_cent.x;			distY = y - p_cent.y;			D2_CENTREST = (distX * distX + distY * distY);			D_NODREST = Math.sqrt(d2_nodeRest);			D_CENTREST = Math.sqrt(d2_centRest);*/			//tubeDist_rest = centDist_rest / 3;			//tubeDist2_rest = centDist2_rest / 3;		}				/***/				/*private function click(e:MouseEvent) {			//doBleb(2);		}*/				/***/		/*public function addPrevVector(v:Vector2D, mag:Number) {			//v.multiplty		}*/						public function addPushVector(v:Vector2D, mag:Number) {			v.multiply(mag);			v_push.addTo(v);		}				/*		public function doPushVector(v:Vector2D, mag:Number) {			var pt_old:Point = new Point(x, y);			v.multiply(mag);			x += v.x;			y += v.y;			var x2:Number = p_next.x;			var y2:Number = p_next.y;			var d2_new:Number = (((x - x2) * (x - x2)) + ((y - y2) * (y - y2))); //get dist2 to p_next			if (d2_new > D2_NODEREST * 2) {				//SNAP!				x = pt_old.x;				y = pt_old.y;			}		}*/						/***/								public function updateDist() {									var x1:Number = x;			var y1:Number = y;			var x2:Number = p_next.x;			var y2:Number = p_next.y;			d2_next = (((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2))); //get dist2 to next node						x2 = p_prev.x; 			y2 = p_prev.y;			var d2_prev:Number = (((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2))); //get dist2 to prev node						x2 = p_cent.x;			y2 = p_cent.y;			d_centx = x1 - x2;			d_centy = y1 - y2;			d2_cent = (((d_centx) * (d_centx)) + ((d_centy) * (d_centy))); //get dist2 to centrosome						x1 = p_prev.x;			y1 = p_prev.y;			x2 = p_next.x;			y2 = p_next.y;			var d2_fold:Number = (((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2))); //get dist2 to fold						if (d2_fold < MembraneNode.D2_NODEREST) {				foldRatio = d2_fold / MembraneNode.D2_NODEREST;			}else {				foldRatio = 1;			}						if (index == 0) {				D2_CENT = D2_CENT_NEW;				D2_CENT_NEW = 0;			}			if (d2_cent > D2_CENT_NEW) {				D2_CENT_NEW = d2_cent;			}									dpull_prev = D2_NODEREST - d2_prev; //positive : PUSH AWAY , negative PULL TOWARDS			dpull_next = D2_NODEREST - d2_next;			dpull_cent = d2_cent - D2_CENTREST;						if (index == 0) {				//trace("dpull p=" + dpull_prev + " n=" + dpull_next);			}									/*if (state_tube) {				x2 = pt_tube.x;				y2 = pt_tube.y;				var d_tube:Number = (((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2))); //get dist2 to tube				dpull_tube = d_tube - d2_tubeRest; 			}*/					churn();			//updateBbody();		}				public function churn() {			old_x = x;			old_y = y;			u_next.Set(x - p_next.x, y - p_next.y);			u_prev.Set(x - p_prev.x, y - p_prev.y);			u_cent.Set(x - p_cent.x, y - p_cent.y);						u_next.normalize();			u_prev.normalize();			u_cent.normalize();						pt_control_next.x = (x + p_next.x) / 2;			pt_control_next.y = (y + p_next.y) / 2;			pt_control_prev.x = (x + p_prev.x) / 2;			pt_control_prev.y = (y + p_prev.y) / 2;						var push:Point = u_cent.multipliedBy(20).toPoint();			var pushMult:Number = 0;						var d2_centRatio:Number = D2_CENT / d2_cent;						pushMult = (d2_centRatio) / (D2_CENT / p_prev.d2_cent);			pushMult = pushMult-1;			pushMult *= 1;						if (isNaN(pushMult)) pushMult = 0;						pt_control_prev.x += push.x * (pushMult);// * foldRatio);			pt_control_prev.y += push.y * (pushMult);// * foldRatio);						pushMult = (d2_centRatio) / (D2_CENT / p_next.d2_cent);			pushMult = pushMult-1;			pushMult *= 1;						if (isNaN(pushMult)) pushMult = 0;			pt_control_next.x += push.x * (pushMult);// * foldRatio);			pt_control_next.y += push.y * (pushMult);// * foldRatio);						/*if (state_tube) {				u_tube.Set(x - pt_tube.x, y - pt_tube.y);				u_tube.normalize();			}*/			var r:Number = u_cent.toRotation() * _180divPI;			r += 90;			rotation = r;						v_push.Set(0, 0); //clear the push vector									var nodeMult:Number = NODE_PULL;			var centMult:Number = CENT_PULL;			//var tubeMult:Number = 0;						//var d2_nodeRest:Number = D2_NODEREST;						/*if (state_ppod || p_prev.state_ppod || p_next.state_ppod) {				centMult = -CENT_PULL * PPOD_MULT;				D2_NODEREST_OLD = D2_NODEREST;			}			else{				if(state_bleb || p_prev.state_bleb || p_next.state_bleb){					//nodeMult = NODE_PULL;					//d2_nodeRest = D2_NODEREST * BLEB_MULT;										//centMult = -CENT_PULL * BLEB_MULT * level_bleb;					//centMult = -CENT_PULL * BLEB_MULT;					centMult = -CENT_PULL * BLEB_MULT;					//d2_nodeRest = D2_NODEREST * BLEB_MULT;					D2_NODEREST_OLD = D2_NODEREST;					//D2_NODEREST = D2_NODEREST * 2;					//tubeMult = 0.5;				}else if (state_blebcontract) {					nodeMult = NODE_PULL * BLEB_CONTRACT_MULT;					centMult = CENT_PULL * BLEB_CONTRACT_MULT;					D2_NODEREST_OLD = D2_NODEREST;				}			}*/						rest_node = true; //set this temporarily to true. If the test fails in either next two case, it is false;						//inline abs functions for speed			var absdpull_next:Number = (dpull_next < 0) ? -dpull_next : dpull_next;			var absdpull_prev:Number = (dpull_prev < 0) ? -dpull_prev : dpull_prev;			var absdpull_cent:Number = (dpull_cent < 0) ? -dpull_cent : dpull_cent;						if (absdpull_next > CLOSE_ENOUGH) {				rest_node = false;				dpull_next /= D2_NODEREST;				dpull_next *= nodeMult;				//addPushVector(u_next, dpull_next);				v_next = u_next.multipliedBy(dpull_next); 			}			if (absdpull_prev > CLOSE_ENOUGH) {				rest_node = false;				dpull_prev /= D2_NODEREST;				dpull_prev *= nodeMult;				//addPushVector(u_prev, dpull_prev);				v_prev = u_prev.multipliedBy(dpull_prev);			}			if (absdpull_cent > CLOSE_ENOUGH) {				v_cent = u_cent.copy();				v_cent.multiply( -centMult);			}						/*var frictForce:Vector2D;			if(state_ppod){	//pseudopoding				addPushVector(f_ppod, 1.0);								frictForce = f_ppod.copy(); 				frictForce.normalize(); 				frictForce.multiply( -1);				frictForce.multiply(PPOD_FRICT);				f_ppod.addTo(frictForce);								if (f_ppod.length < 1) {					endPPod();				}			}			else if (state_bleb) {				addPushVector(f_bleb, 1.0);								frictForce = f_bleb.copy();				frictForce.normalize();				frictForce.multiply( -1);				frictForce.multiply(BLEB_FRICT);				f_bleb.addTo(frictForce);								if (f_bleb.length < 1) {					endBleb();				}				if (Membrane.AVG_STRETCH < Membrane.MIN_STRETCH) {					endBleb();				}			}else if (state_blebcontract) {				count_bleb--;				if (count_bleb <= 0) {					count_bleb = 0;					endBlebContract();				}			}*/						updateStretch();						//if (state_ppod) {			if (hasRNA) {				for each(var rna:RNA in list_rna) {					rna.mnodeMove(x-old_x, y-old_y);				}			}			//}		}				public function tugNodes() {			/*p_prev.x -= tug_prev_x * FRICT;			p_prev.y -= tug_prev_y * FRICT;						p_next.x += tug_next_x * FRICT;			p_next.y += tug_next_y * FRICT;*/		}				public function doCellMove(xx:Number, yy:Number) {			x += xx;			y += yy;		}				public function doMove() {																								xdist = (v_next.x * FRICT) + (v_prev.x * FRICT) + (v_cent.x);			ydist = (v_next.y * FRICT) + (v_prev.y * FRICT) + (v_cent.y);						// Go ahead and add the distances			x += xdist;			y += ydist;						/*			// If it puts us in a bad position, correct it.			// First we check to see if this node is counter clockwise of the previous.			if (checkClockwiseNodes(this, p_prev, p_cent)) 			{									trace("Prev!");				// If so, we provide an adjustment in the clockwise direction.				// We use the vector (vec_x, vec_y) from centrosome to node, then take a normalized				// perpendicular and scale it somewhat arbitrarily by half of what it moved anyway.  				var vec_x:Number = x-p_cent.x;				var vec_y:Number = y-p_cent.y;				var mag:Number = Math.sqrt(vec_x*vec_x + vec_y*vec_y);				x += (vec_y/mag)*(xdist);				y += (-vec_x/mag)*(ydist);			}			if (checkClockwiseNodes(p_next, this, p_cent)) // Then verify it isn't clockwise of next.			{				trace("Next!");				// If so, then we adjust counter-clockwise.  If we hit both, then they'll cancel out, which is probably best.				var vec_x:Number = x-p_cent.x;				var vec_y:Number = y-p_cent.y;				var mag:Number = Math.sqrt(vec_x*vec_x + vec_y*vec_y);				x += (-vec_y/mag)*(xdist);				y += (vec_x/mag)*(ydist);			}			else			{				// Do nothing, we're good			}*/								/*x += v_prev.x * FRICT;				y += v_prev.y * FRICT;								x += v_cent.x;				y += v_cent.y;*/															updateLoc();					}				// Checks to see if n1 is more clockwise than n2.  Returns true is n1 is clockwise, false if counter clockwise.		// We define clockwise as being 0 <= n1 - n2 <= PI)				private function checkClockwiseNodes(n1:MembraneNode, n2:MembraneNode, cent:Centrosome):Boolean{			var theta1:Number = Math.atan2(n1.y-cent.y, n1.x-cent.x);			var theta2:Number = Math.atan2(n2.y-cent.y, n2.x-cent.x);			var thetaDiff:Number = boundTheta(theta1 - theta2); 			if (thetaDiff > 0 && thetaDiff < Math.PI) // We're defining "clockwise" as being less than Pi clockwise around				return true;			else				return false;		}				// Bound polar Theta value between 0 and 2Pi		private function boundTheta(n:Number):Number {			var Pi2:Number = 2 * Math.PI;			if (n < 0)				return (n + Pi2);			else if (n > Pi2)				return (n - Pi2);			else				return n;		}								public function placeInGrid() {			var xx:Number = x - p_cent.x + span_w / 2;			var yy:Number = y - p_cent.y + span_h / 2;						gdata.x = xx;			gdata.y = yy;						grid_x = int(xx/grid_w);			grid_y = int(yy/grid_h);						p_grid.putIn(grid_x,grid_y,gdata);		}				private function updateLoc() {			var xx:Number = d_centx + span_w / 2;			var yy:Number = d_centy + span_h / 2;						gdata.x = xx;			gdata.y = yy;						var old_x:int = grid_x;			var old_y:int = grid_y;			grid_x = int(xx/grid_w);			grid_y = int(yy / grid_h);						if (grid_x < 0) grid_x = 0;			if (grid_y < 0) grid_y = 0;			if (grid_x > grid_w) grid_x = grid_w - 1;			if (grid_y > grid_h) grid_y = grid_h - 1;								if ((old_x != grid_x) || (old_y != grid_y)) {				p_grid.takeOut(old_x,old_y,gdata);				p_grid.putIn(grid_x,grid_y,gdata);			}		}						public function applyGravities() {			v_grav.Set(0, 0); //clear gravity vector			/*var gp:Vector2D.<Number> = p_membrane.getGravityPoints();			for (var i:int = 0; i < gp.length; i++) {				applyGravity(gp[i]);							}*/		}				public function applyGravity(xx:Number,yy:Number) {			u_grav.Set(x - xx, y - yy);			var x1:Number = x;			var y1:Number = y;			var x2:Number = xx;			var y2:Number = yy;			var dist2:Number = (((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2)));			u_grav.normalize();			u_grav.multiply(GRAVITY/2/dist2);						v_grav.addTo(u_grav);		}				/*public function endPPod() {			f_ppod.Set(0, 0);			state_ppod = false;						level_ppod = -1;					}				public function endBlebContract() {			state_blebcontract = false;		}				public function endBleb() {			f_bleb.Set(0, 0);			state_bleb = false;			//start bleb contract			state_blebcontract = true;			count_bleb = BLEB_TIME;			//			level_bleb = -1;			if (p_prev.state_bleb == false && p_next.state_bleb == false) {				D2_NODEREST = D2_NODEREST_OLD;			}		}*/				/*public function doPpod(extra:Number) {			if(p_membrane.skeletonReady == true){				if((!state_ppod)){					if (level_ppod == -1) {						level_ppod = extra;												state_ppod = true;						f_ppod = u_cent.copy();						f_ppod.multiply(power_ppod + (power_ppod) * extra);					}					if (extra > 0) {						p_prev.doPpod(extra - 1);						p_next.doPpod(extra - 1);					}				}			}		}				public function doBleb(extra:Number,v:Vector2D=null) {			if(p_membrane.skeletonReady == true){				if((!state_bleb && stretch > 0.75)){					if (level_bleb == -1) {						level_bleb = extra;												state_bleb = true;						if (v) {							f_bleb = v.copy();							f_bleb.normalize();						}else {							f_bleb = u_cent.copy();							}						f_bleb.multiply(power_bleb);					}					if (extra > 0) {						p_prev.doBleb(extra - 1);						p_next.doBleb(extra - 1);					}				}			}		}*/			}	}