package com.pecLevel{	import flash.events.EventDispatcher;	// We handle and dispatch events, so we need to extend EventDispatcher	public class ObjectiveHandler extends EventDispatcher{				// ***Private members***		private var objectiveList:Vector.<Objective>;		private var clearList:Vector.<Objective>;		private var p_engine:Engine;		private var waitForDelay:Boolean = false; //are we currently waiting for any delayed objectives?		// ***Public methods***				// Constructor		public function ObjectiveHandler(){			objectiveList = new Vector.<Objective>();			clearList = new Vector.<Objective>();		}				public function setEngine(p:Engine){			p_engine = p; 			initListeners();		}				// Add an objective to the active list.		public function addObjective(obj:Objective):void {			objectiveList.push(obj);		}				// Clear out all current objectives.  Usually done at start of a level or on death.		public function resetObjectives():void {			// Iterates over and clears out the objective list.			while (objectiveList.length > 0){				objectiveList.pop()			}		}				// Find out how many objectives we have in total (completed + incomplete)		// This is useful when showing a list of objectives (and crossing off completed ones)		public function getNumObjectives():int {			return objectiveList.length;		}				// Obtain a specific objective. 		public function getObjective(i:int):Objective {			return objectiveList[i];		}					public function activateObjective(s:String):Boolean {			//trace("ObjectiveHandler.activateObjective() str=" + s);			for each (var o:Objective in objectiveList) {				if (!o.active && o.id == s) {					o.active = true;					//trace("ObjectiveHandler.activateObjective()" + o);					return true;				}			}			return false;		}				// ***Private Functions***				// Set up some listeners		private function initListeners(){			addEventListener(EngineEvent.THING_CREATE, updateThing,false,0,true);			addEventListener(EngineEvent.THING_DESTROY, updateThing, false, 0, true);			addEventListener(EngineEvent.THING_CHANGE, updateThingChange, false, 0, true);			addEventListener(EngineEvent.RESOURCE_CHANGE, updateResource, false, 0, true);			addEventListener(EngineEvent.EXECUTE_ACTION, updateAction, false, 0, true);			addEventListener(EngineEvent.FAIL_ACTION, updateFailAction, false, 0, true);			addEventListener(EngineEvent.ENGINE_TRIGGER, onTrigger, false, 0, true);			addEventListener(EngineEvent.SELECT_THING, onSelect, false, 0, true);			addEventListener(EngineEvent.THROW_FLAG, onFlag, false, 0, true);			addEventListener(EngineEvent.ENEMY_ALERT, onEnemyAlert, false, 0, true);			addEventListener(EngineEvent.ENEMY_SURVIVE, onEnemySurvive, false, 0, true);		}			// e.targetNum is the current AMOUNT of those things		private function updateThingChange(e:EngineEvent):void {			var i:int = 0;			for each(var obj:Objective in objectiveList) {				if (!obj.objectiveComplete && !obj.objectivePending && obj.objectiveType == ObjectiveType.HAVE_THING) {										if( obj.targetType == e.targetType){						obj.objectiveProgress = e.targetNum;						checkObjectiveProgress(obj);					}				}				i++;			}		}				// e.targetNum is expected to be negative if the number of things went down.		// e.targetNum is the CHANGE in those things since the objective was executed		private function updateThing(e:EngineEvent):void {			var i:int = 0;			//for (i = 0; i < objectiveList.length; i++) {			for each(var obj:Objective in objectiveList){				if (!obj.objectiveComplete && !obj.objectivePending && obj.objectiveType == ObjectiveType.GET_THING || obj.objectiveType == ObjectiveType.LOSE_THING) {					if(obj.targetType == e.targetType){						obj.objectiveProgress += e.targetNum;						checkObjectiveProgress(obj);					}				}				i++;			}		}				// e.targetNum is expected to be the correct value of the resource, not the change (delta) in it		private function updateResource(e:EngineEvent):void {			var i:int = 0;						for each(var obj:Objective in objectiveList) {								if (!obj.objectiveComplete && !obj.objectivePending && obj.objectiveType == ObjectiveType.HAVE_RESOURCE) {					if(obj.targetType == e.targetType){						obj.objectiveProgress = e.targetNum;						checkObjectiveProgress(obj);					}				}				i++;			}		}				private function updateFailAction(e:EngineEvent):void {			var i:int = 0;						for each(var obj:Objective in objectiveList) {				if (!obj.objectiveComplete && !obj.objectivePending && obj.objectiveType == ObjectiveType.FAIL_ACTION) {					if (obj.targetType == e.targetType) {						obj.objectiveProgress += e.targetNum;						checkObjectiveProgress(obj);					}				}				i++;			}		}				// e.targetNum is generally 1, but could be more if we, say, recycle 20 ribosomes at once		private function updateAction(e:EngineEvent):void {			var i:int = 0;			for each(var obj:Objective in objectiveList) {				if (!obj.objectiveComplete && !obj.objectivePending && obj.objectiveType == ObjectiveType.DO_ACTION) {					if(obj.targetType == e.targetType){						obj.objectiveProgress += e.targetNum;						checkObjectiveProgress(obj);					}				}				i++;			}		}				//e.targetNum is the number select, 1 in the case of normal stuff		private function onSelect(e:EngineEvent):void {			var i:int = 0;			//trace("ObjectiveHandler.onSelect(" + e + ")");			for each(var obj:Objective in objectiveList) {				if(!obj.objectiveComplete && !obj.objectivePending && obj.objectiveType == ObjectiveType.SELECT) {					if (obj.targetType == e.targetType) {						//trace("ObjectiveHandler.onSelect() type = " + obj.targetType + " obj.targetNum = " + obj.targetNum + " e.targetNum = " + e.targetNum);						obj.objectiveProgress = e.targetNum;						checkObjectiveProgress(obj);					}				}				i++;			}					}				private function onEnemySurvive(e:EngineEvent):void {			var i:int = 0;			for each(var obj:Objective in objectiveList) {				if (!obj.objectiveComplete && !obj.objectivePending && obj.objectiveType == ObjectiveType.ENEMY_SURVIVE) {					if (obj.targetType == e.targetType) { //if the waves match up						obj.objectiveProgress = 1; 		  //should work with TRUE condition						checkObjectiveProgress(obj);					}				}				i++;			}					}				private function onEnemyAlert(e:EngineEvent):void {			var i:int = 0;			for each(var obj:Objective in objectiveList) {				if (!obj.objectiveComplete && !obj.objectivePending && obj.objectiveType == ObjectiveType.ENEMY_ALERT) {					if (obj.targetType == e.targetType) {		//if the enemy types match up						obj.objectiveProgress = e.targetNum;	//set the progress to the number of enemies alerted						checkObjectiveProgress(obj);					}				}				i++;			}		}				private function onFlag(e:EngineEvent):void {			var i:int = 0;			//trace("ObjectiveHandler.onFlag(" + e + ")");			for each(var obj:Objective in objectiveList) {				//trace("ObjectiveHandler.onFlag objectiveList = " + objectiveList);				if (!obj.objectiveComplete && !obj.objectivePending && obj.objectiveType == ObjectiveType.THROW_FLAG) {					if (obj.targetType == e.targetType) {			//if the flag names match up							obj.objectiveProgress = e.targetNum;	//set the progress to the number of times flag has been thrown							checkObjectiveProgress(obj);					}				}				i++;			}		}				//e.targetNum is always 1		private function onTrigger(e:EngineEvent):void {			var i:int = 0;			//trace("ObjectiveHandler.onTrigger()");			for each(var obj:Objective in objectiveList) {				//trace("ObjectiveHandler.onTrigger() e.eventType = " + e.eventType + " obj.objectiveType = " + obj.objectiveType);				if (!obj.objectiveComplete && !obj.objectivePending && obj.objectiveType == e.eventType) {										var success:Boolean = false;					if (e.targetType == "null" || obj.targetType == "null") {	//if we don't care about the target type						success = true;					}else if (e.targetType == obj.targetType) { //if we do, make sure they match						success = true;					}										//trace("ObjectiveHandler.onTrigger() e.targetType = " + e.targetType + " obj.targetType = " + obj.targetType);										if (success) {						if(obj.targetCondition == ObjectiveCondition.IS_TRUE){							obj.objectiveProgress = 1;						}else {							obj.objectiveProgress = e.targetNum;						}						checkObjectiveProgress(obj);					}				}				i++;			}		}				// Checks on the progress of an objective and handles it if it is complete.		private function checkObjectiveProgress(obj:Objective):Boolean {			//trace("ObjectiveHandler.checkObjectiveProgress() checking progress...");						var cond:String = obj.targetCondition;						if (cond == ObjectiveCondition.IS_TRUE) {				if(obj.objectiveProgress){					return dispatchCompleteObjective(obj);				}			}else if (cond == ObjectiveCondition.IS_FALSE){				if(!obj.objectiveProgress){					return dispatchCompleteObjective(obj);				}			}else if(cond == ObjectiveCondition.EQ_TO){				if(obj.objectiveProgress == obj.targetNum){					return dispatchCompleteObjective(obj);				}			}else if(cond == ObjectiveCondition.GRTR_THAN){				if(obj.objectiveProgress > obj.targetNum){					return dispatchCompleteObjective(obj);				}			}else if(cond == ObjectiveCondition.LESS_THAN){				if(obj.objectiveProgress < obj.targetNum){					return dispatchCompleteObjective(obj);				}			}else if(cond == ObjectiveCondition.GRTR_OR_EQ_TO){				if(obj.objectiveProgress >= obj.targetNum){					return dispatchCompleteObjective(obj);				}			}else if (cond == ObjectiveCondition.LESS_OR_EQ_TO) {				if(obj.objectiveProgress <= obj.targetNum){					return dispatchCompleteObjective(obj);				}			}else {				trace("ObjectiveHandler.checkObjectiveProgress() ERROR! Objective Condition \"" + cond + "\" not recognized!");			}			return false;		}				// Dispatches the alert for the engine.  i is the index of the event into objectiveList		private function dispatchCompleteObjective(obj:Objective):Boolean{			//trace("ObjectiveHandler.dispatchCompleteObjective() -- Success!");						if(obj.delay <= 0 || isNaN(obj.delay)){				// Mark the objective complete in the list. 				obj.objectiveComplete = true;				//trace("ObjectiveHandler.dispatchCompleteObjective() " + objectiveList);				// Dispatch an event to the engine (to be caught by the engine) indicating that this objective is complete.				var e = new ObjectiveEvent(obj, ObjectiveEvent.COMPLETE)				p_engine.dispatchEvent(e);				clearObjective(obj);				return true;			}else {				if (!waitForDelay) {					//trace("ObjectiveHandler.dispatchCompleteObjective() : delay " + objectiveList[i].delay);					waitForDelay = true;					addEventListener(RunFrameEvent.RUNFRAME, checkDelay,false,0,true); //only run this listener when we have an actively delayed objective				}				obj.delayProgress = 0;				obj.objectivePending = true;				//clearObjective(obj);				return true;			}			return false;		}				private function clearObjective(obj:Objective) {						//trace("ObjectiveHandler.clearObjective() objectiveList.length BEFORE= " + objectiveList.length);			for (var i:int = 0; i < objectiveList.length; i++) {				if (objectiveList[i] == obj) {					objectiveList.splice(i, 1);					i--;					clearList.push(obj);				}			}			//trace("ObjectiveHandler.clearObjective() objectiveList.length AFTER= " + objectiveList.length);		}				private function checkDelay(r:RunFrameEvent) {			var i:int = 0;			var doneWaiting:Boolean = true;			for each(var obj:Objective in objectiveList) {				if (obj.objectivePending) {					obj.delayProgress++;					if (obj.delayProgress >= obj.delay) {						obj.delayProgress = obj.delay;						obj.delay = 0;					//set the delay to 0 so it'll dispatch when we hand it off						obj.objectivePending = false;	//set pending to false so it will never trip this switch again						//trace("ObjectiveHandler.checkDelay() objective " + i + " ready!");						dispatchCompleteObjective(obj);   //dispatch it. Won't wait because the delay is now 0					}else {						doneWaiting = false;					}				}				i++;			}			if (doneWaiting) {				//trace("ObjectiveHandler.checkDelay() done waiting entirely!");				removeEventListener(RunFrameEvent.RUNFRAME, checkDelay);				waitForDelay = false;			}		}											}}