package com.woz{		/**	 * ...	 * @author Lars A. Doucet	 */		import com.pecLevel.EngineEvent;	import com.pecLevel.LevelData;	import com.pecLevel.LevelStuff;	import com.pecLevel.LevelThings;	import com.pecLevel.StuffEntry;	import com.pecLevel.ThingEntry;	import com.pecLevel.WaveEntry;	import flash.events.EventDispatcher;	 	public class WizardOfOz extends EventDispatcher	{		private var p_engine:Engine;		private var p_cell:Cell;		private var p_canvas:WorldCanvas;		private var p_virusGlass:VirusGlass;				//free resources just kickin' around		private var g_aa:GoodieData;		private var g_na:GoodieData;		private var g_fa:GoodieData;		private var g_g:GoodieData;				private var world_w:Number;		private var world_h:Number;		private var world_area:Number;				private var list_goodies:Vector.<GoodieData>;		private var list_puddles:Vector.<PuddleData>;		private var list_cells:Vector.<CellData>;				private var list_toxins:Vector.<ToxinData>;		private var list_viruses:Vector.<VirusData>;		private var list_waves:Vector.<WaveEntry>;		private var list_bacteria:Vector.<BacteriaData>;						private var list_objects:Vector.<EntityData>;				private const NA_DROP:int = 1;		private const AA_DROP:int = 5*Costs.AAX;		private const FA_DROP:int = 2;		private const G_DROP:int = 2;				private const GOODIE_AREA:Number = 50 * 50 * 3.1415926535897932384626433832795; 		private const VIRUS_AREA:Number = 10 * 10 * 3.1415926535897932384626433832795; 		private var lensRadius:Number = 0;		public static var LENS_RADIUS:Number = 0;		public static var LENS_RADIUS2:Number = 0;		private var visible_area:Number = 0;				private const CHANCE_BIG:Number = 0.05; //5% chance of getting big			    (05% only big)		private const CHANCE_MID:Number = 0.30; //30% chance of at least getting medium (25% only medium)		private const CHANCE_SMALL:Number = 1;  //100% chance of at least getting small (70% only small)						private const TICK_TIME:int = 15;		private var tick_count:int = 0;				private var tick_space_count:int = 0;		private const TICK_SPACE_TIME:int = 5;				private var wave_tick:int = 0;		private var WAVE_TIME:int = 30; //we check for new waves every second		private var wave_ticking:Boolean = false;				public function WizardOfOz() 		{					}				public function init(lData:LevelData,lensSize:Number=100) {			var stuff:LevelStuff = lData.levelStuff;			var things:LevelThings = lData.levelThings;						g_na = makeBasicGoodie("na_batch", "na", 0, 0);			g_aa = makeBasicGoodie("aa_batch", "aa", 0, 0);			g_fa = makeBasicGoodie("fa_batch", "fa", 0, 0);			g_g = makeBasicGoodie("g_batch", "g", 0, 0);			//trace("WizardOfOz.init() na=" + g_na.active + " aa=" + g_aa.active + " fa=" + g_fa.active + " g_g" + g_g.active);						world_w = lData.size_width * Terrain.SCALE_MULT;			world_h = lData.size_height * Terrain.SCALE_MULT;						var s:StuffEntry;			for each (s in stuff.goodies) {				var g:GoodieData = lookupGoodieData(s.stuff_type);				if (g) {					g.count = s.stuff_count;					g.spawn = s.stuff_spawn;					g.active = s.active;					//trace("WizardOfOz.init() goodie:type=" + s.stuff_type + " active=" + s.active);				}								if (s.stuff_type == "na") {					g_na.count = s.stuff_count;					g_na.spawn = s.stuff_spawn;					g_na.active = s.active;				}else if (s.stuff_type == "aa") {					g_aa.count = s.stuff_count;					g_aa.spawn = s.stuff_spawn;					g_aa.active = s.active;				}else if (s.stuff_type == "fa") {					g_fa.count = s.stuff_count;					g_fa.spawn = s.stuff_spawn;					g_fa.active = s.active;				}else if (s.stuff_type == "g") {					g_g.count = s.stuff_count;					g_g.spawn = s.stuff_spawn;					g_g.active = s.active;				}			}				//trace("WizardOfOz.init() na=" + g_na.active + " aa=" + g_aa.active + " fa=" + g_fa.active + " g_g" + g_g.active);			list_viruses = new Vector.<VirusData>;			for each (s in stuff.enemies) {				var v:VirusData = new VirusData();				if (v) {					v.count = s.stuff_count;					v.spawn = s.stuff_spawn;					v.active = s.active;					v.aggro = s.stuff_aggro;					v.type = s.stuff_type;					//trace("WizardOfOz.init() goodie:type=" + s.stuff_type + " active=" + s.active);				}							list_viruses.push(v);			}			for each (s in stuff.objects) {							}			var t:ThingEntry;			for each (t in things.goodies) {				/*var g:GoodieData = new GoodieData();				g.name = t.thing_name;				g.type = t.thing_type;				g.count = t.thing_count;				g.aggro = t.thing_aggro;*/			}						list_waves = new Vector.<WaveEntry>;			for each(var w:WaveEntry in things.waves) {				var we:WaveEntry = new WaveEntry();				we.count = w.count;				we.original_count = w.count;				we.frac = Number(w.count) / Number(we.original_count);				we.active = w.active;				we.delay = w.delay;				we.id = w.id;				we.spread = w.spread;				we.type = w.type;				we.vesicle = w.vesicle;				we.dormant_time = 0;				we.sleep_seconds = w.sleep_seconds;				list_waves.push(we);			}			//trace("WizardOfOz.init() list_waves = " + list_waves);			updateLensSize(lensSize);			addEventListener(RunFrameEvent.RUNFRAME, tickTime);		}		public function checkLevelBatch(s:String):Boolean {			if (s == "aa") {				return g_aa.active;			}else if (s == "na") {				return g_na.active;			}else if (s == "fa") {				return g_fa.active;			}else if (s == "g") {				return g_g.active;			}			return false;		}				public function activateStuff(id:String) {			if (id == "na_batch") {				g_na.active = true;			}else if (id == "aa_batch") {				g_aa.active = true;			}else if (id == "fa_batch") {				g_fa.active = true;			}else if (id == "g_batch") {				g_g.active = true;			}			//trace("WizardOfOz.activateStuff(" + id + ")");			//trace("WizardOfOz.activateStuff() na=" + g_na.active + " aa=" + g_aa.active + " fa=" + g_fa.active + " g=" + g_g.active);		}				public function lookupWaveData(s:String):WaveEntry {			for each(var w:WaveEntry in list_waves) {				if (w.id == s) {					return w;				}			}			return null;		}				public function lookupVirusData(s:String):VirusData {			for each(var v:VirusData in list_viruses) {				if (v.type == s) {					return v;				}			}						return null;		}				public function lookupGoodieData(s:String):GoodieData {			if (s == "na") return g_na;			if (s == "aa") return g_aa;			if (s == "fa") return g_fa;			if (s == "g") return g_g;			return null;		}				public function destruct() {			p_engine = null;			p_canvas = null;			p_cell = null;						//destroy all your vectors		}				public function setEngine(e:Engine) {			p_engine = e;			p_virusGlass = p_engine.c_interface.c_tutorialGlass.c_virusGlass; //HACK HACK HACK		}				public function setCell(c:Cell) {			p_cell = c;		}				public function setCanvas(wc:WorldCanvas) {			p_canvas = wc;		}				public function updateLensSize(r:Number) {			lensRadius = r;			LENS_RADIUS = r;			LENS_RADIUS2 = r * r;			visible_area = r * r * Math.PI;			p_canvas.updateLensSize(r);		}				private function makeBasicGoodie(name:String, type:String, count:int, spawn:Number):GoodieData{			var g:GoodieData = new GoodieData();			g.name = name;			g.type = type;			g.count = count;			g.spawn = spawn;			g.aggro = 0;			g.is_thing = false;			g.active = false;			//trace("WizardOfOz.makeBasicGoodie() type=" + type);			return g;		}				/*public function onCellMove() {			tickSpace();		}*/				public function tickSpace() {			tick_space_count++;			if (tick_space_count > TICK_SPACE_TIME) {				tick_space_count = 0;				doTickSpace();			}		}				public function tickTime(r:RunFrameEvent) {			tick_count++;			if (tick_count > TICK_TIME) {				tick_count = 0;				doTickTime();			}		}				public function tickWave(r:RunFrameEvent) {			wave_tick++;			if (wave_tick > WAVE_TIME) {				wave_tick = 0;				doWaveTick();			}		}						private function doTickSpace() {			if(g_na.active)				tickGoodieEncounter(g_na);			if(g_aa.active)				tickGoodieEncounter(g_aa);			if(g_fa.active)				tickGoodieEncounter(g_fa);			if(g_g.active)				tickGoodieEncounter(g_g);		}				private function doTickTime() {			tickResources();			//tickEncounters();		}				private function tickResources() {			if(g_na.active)				tickResource(g_na);			if(g_aa.active)				tickResource(g_aa);			if(g_fa.active)				tickResource(g_fa);			if(g_g.active)				tickResource(g_g);			//trace("WizardOfOz.tickResources() na: " + g_na.count + " aa:" + g_aa.count + " g_fa:" + g_fa.count + " g_g:" + g_g.count);		}				private function tickResource(g:GoodieData) {			if (Math.random() <= g.spawn) {				g.count += 1;				//trace("WizardOfOz.tickResource() na: " + g_na.count + " aa:" + g_aa.count + " g_fa:" + g_fa.count + " g_g:" + g_g.count);				//trace("WizardOfOz.tickResource() " + g.type + " count = " + g.count);			}		}		public function absorbCellObject(c:CellObject,justKill:Boolean=false):Boolean {			//trace("WizardOfOz.absorbCellObject(" + c + ")");			var i:int = c.num_id;			var success:Boolean = false;			switch(i) {				//case Selectable.VIRUS:								case Selectable.VIRUS_INJECTOR:				case Selectable.VIRUS_INVADER: 				case Selectable.VIRUS_INFESTER: success = true;  												if (!justKill) {													absorbVirus(Virus(c)); 												}break;				default: success = true; break;			}			return success;		}		public function onVirusInfest(wave:String, count:int) {			if (wave != "") {				var we:WaveEntry = lookupWaveData(wave);				if (we) {					we.infest_count++;				}			}		}				public function onVirusEscape(wave:String, count:int) {			if (wave != "") {				var we:WaveEntry = lookupWaveData(wave);				if (we) {					we.escaped_count++;				}			}			//trace("WizardOfOz.onVirusEscape() entry = " + we + " we.escaped_count = " + we.escaped_count);		}				/**		 * Whenever a virus is spawned in the cell		 * @param	wave		 * @param	count		 */				public function onVirusSpawn(wave:String, count:int) {			if (wave != "") {				var we:WaveEntry = lookupWaveData(wave);				if (we) {					we.spawned_count++;				}			}			//trace("WizardOfOz.onVirusSpawn() entry = " + we + " we.spawned_count = " + we.spawned_count);		}				/**		 * Whenever ANY virus is created		 * @param	type		 * @param	wave		 * @param	count		 */				public function onVirusBorn(type:String,wave:String,count:int) {			if (wave != "") {				var we:WaveEntry = lookupWaveData(wave);				if (we) {					we.dormant_time = 0;					p_virusGlass.updateLineCounts(we.id, -1, -1, we.count, -1);				}			}		}				public function absorbVirus(v:Virus) {			//trace("WizardOfOz.absorbVirus( virus type=" + v.text_id + " wave id =" + v.wave_id + ")");			if (v.wave_id != "") {				var we:WaveEntry = lookupWaveData(v.wave_id);				if (we) {					//trace("WizardOfOx.absorbVirus found wave entry!");					we.count += 1;					//if (we.count <= we.original_count / 2) {					we.dormant_time = 0; //reset the dormant time each time a virus "escapes"					p_virusGlass.updateLineCounts(we.id, -1, -1, we.count, -1);					//}//else {					//	p_virusGlass.updateLineCounts(we.id, -1, -1, we.count, we.sleep_seconds);					//}										//we.frac = Number(we.count) / Number(we.original_count);					//trace("WizardOfOz.absorbVirus("+we.id+") count=" + we.count);				}			}else {				//trace("WizardOfOx.absorbVirus NOT found wave entry!");				var vd:VirusData = lookupVirusData(v.text_id)				if(vd){					vd.count += 1;					//trace("WizardOfOz.absorbVirus(" + vd.type + ") count=" + vd.count);				}			}		}				public function absorbGoodieGem(s:String) {			var g:GoodieData = lookupGoodieData(s);			//trace("WizardOfOz.absorbGoodieGem()" + s + ": " + g.count);			g.count += 1;			//trace("WizardOfOz.absorbGoodieGem()" + s + ": now : " + g.count);			//trace("WizardOfOz.tickResources() na: " + g_na.count + " aa:" + g_aa.count + " g_fa:" + g_fa.count + " g_g:" + g_g.count);		}				private function tickSpaceEncounters(){		}				private function doWaveTick(){			for each(var w:WaveEntry in list_waves) {				if (w.active && w.count > 0) { //if it's active and it's got viruses waiting to be released					tickWaveEncounter(w);				}			}		}						public function getWave(wave:String):WaveEntry {			for each(var w:WaveEntry in list_waves) {				if (w.id == wave) {					return w.copy();				}			}			return null;		}				/**		 * Searches for the corresponding wave, and if it finds it, sets it to defeated		 * @param	s the name of the wave		 * @return whether there are any active, undefeated waves or not		 */				public function defeatWave(s:String):Boolean {			var isSafe:Boolean = true;			for each(var w:WaveEntry in list_waves) {				if(w){					if (w.id == s) {						w.defeated = true;						//trace("WizardOfOz.defeatWave(" + s + ")");						w.active = false;					}										if (w.active && !w.defeated) { //there is an active, undefeated wave						//trace("WizardOfOz.defeatWave(" + s + ") UNSAFE! Wave " + w.id + " still is out there!");						isSafe = false;					}				}			}			if (isSafe) {				//trace("WizardOfOz.defeatWave(" + s + ") SAFE! Remove tickWave()!");				removeEventListener(RunFrameEvent.RUNFRAME, tickWave);			}			return isSafe;		}				public function onCreateWave(s:String) {			for each(var w:WaveEntry in list_waves) {				if (w.id == s) {					w.active = true;					w.count = 0;					w.dormant_time = 0;				}			}			addEventListener(RunFrameEvent.RUNFRAME, tickWave,false,0,true);		}				public function neutralizeViruses() {			for each(var w:WaveEntry in list_waves) {				//trace("WizardOfOz.neutralizeViruses(" + w.id + ")");				w.active = false;				w.count = 0;			}		}				private function tickWaveEncounter(w:WaveEntry) {			w.dormant_time++; 							 //sleep a little			p_virusGlass.updateLineCounts(w.id, -1, -1,w.count, w.sleep_seconds - w.dormant_time);						/*if (w.dormant_time == 1) { //it's been asleep for 1 second!				//p_engine.notifyOHandler(EngineEvent.ENGINE_TRIGGER, "virus_dormant", w.id, w.count);			}			else */						if(w.dormant_time >= w.sleep_seconds){  //if its been asleep long enough				w.dormant_time = 0;						 //release them all!				p_engine.createWave(w);				p_virusGlass.updateLineCounts(w.id, -1, -1, 0, w.sleep_seconds); //no more dormants			}		}				private function tickVirusEncounter(v:VirusData) {			var encounter_size:Number = visible_area * 2;			var virus_size:Number = v.count * VIRUS_AREA;			var ratio:Number = virus_size / encounter_size;			if (Math.random() <= ratio) {				encounterVirus(v);			}		}				private function tickGoodieEncounter(g:GoodieData) {			var encounter_size:Number = visible_area * 2;			var goodie_size:Number = g.count * GOODIE_AREA;			var ratio:Number = goodie_size / encounter_size;			//trace("WizardOfOz.tickGoodieEncounter() encounter_size = " + encounter_size + " goodie_size = " + goodie_size + " ratio = " + ratio);			if (Math.random() <= ratio) {				//trace("WizardOfOz.tickGoodieEncounter() SUCCESS!");				encounterGoodie(g);			}		}				private function encounterVirus(v:VirusData) {			p_canvas.encounterVirus(v.type);		}				private function encounterGoodie(g:GoodieData) {			var amt:int = 0;			//trace("WizardOfOz.encounterGoodie: " + g.type);			if (g.type == "na") {				amt = NA_DROP;				g_na.count--;			}else if (g.type == "aa") {				amt = AA_DROP;				g_aa.count--;			}else if (g.type == "fa") {				amt = FA_DROP;				g_fa.count--;			}else if (g.type == "g") {				amt = G_DROP;				g_g.count--;			}						var r:Number = Math.random();			if(r <= CHANCE_BIG){				p_canvas.encounterGoodieGem(g.type, amt * 4);			}else if (r <= CHANCE_MID) {				p_canvas.encounterGoodieGem(g.type, amt * 2);			}else{				p_canvas.encounterGoodieGem(g.type, amt);			}		}			}	}