package  {	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.ui.Keyboard;		/**	 * ...	 * @author Lars A. Doucet	 */	public class Test extends MovieClip	{				private var scale:Number = 1; // Zoom level multiplied by SCALE_MULT		private var zoom:Number = 1; // Zoom level 		private var levelW:Number = 1; // Size of the full level (actually the sprite size) in pixels, same scale as absScroll.		private var levelH:Number = 1; // See above.		private var levelScaleW:Number = 1; // A scale that relates the sprite size to the level size		private var levelScaleH:Number = 1; // See above.			private var BMPCornerX:Number = 0; // This tells us where the top-left corner of our rendered BMP is, relative to the game level.  This allows us to determine when we need a redraw.		private var BMPCornerY:Number = 0; // See above.		private var relScrollX:Number = 0; // This is the relative X position within the drawn BMP.  Changes when BMP is rerendered.		private var relScrollY:Number = 0; // See above.				// Constants for the stage size.  		private const STAGE_W:Number = 640;		private const STAGE_H:Number = 480;		public static const SCALE_MULT:Number = 10; // ?		private const BUFFER_RATIO:Number = 1.4; // This is the ratio of overdraw on each side, so 1.5 would draw 25% extra on both the left and the right.				private var c_sprite:Sprite; // The full sprite that contains the entire background image		private var bmp_terrain:Bitmap; // Bitmap that is rendered to the screen		private var data_terrain:BitmapData; // Bitmap data for bmp_terrain				//private var pixelsW:Number = 1; 		//private var pixelsH:Number = 1;				private var renderMat:Matrix; // The render renderMat that includes scale and transformation				//private var t_width:Number;		//private var t_height:Number;				// The pending values will be picked up by a function (checkPending) that runs every frame. 		private var pendingScroll:Array = [0, 0]; // Represents scroll requests, either from the user via arrows, or due to cell movement or view centering		private var pendingZoom:Number = 0; // Represents zoom requests, either from user input or for a scripted event.				public function Test() 		{			stage.addEventListener(Event.ENTER_FRAME, checkPending);			stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);			stage.addEventListener(KeyboardEvent.KEY_UP, onKeyUp);						makeMatrix();			makeBMP(100,100);			//changeZoom(1);					}				public function mouseDown(m:MouseEvent) {					}				private function makeSprite(w:Number = 0, h:Number = 0) {			c_sprite = new TerrainSprite_MonsterMouth();		}				private function makeMatrix() {			renderMat = new Matrix();			renderMat.identity();		}				private function makeBMP(w:Number,h:Number) {			makeSprite();						data_terrain = new BitmapData(STAGE_W*BUFFER_RATIO, STAGE_H*BUFFER_RATIO,false, 0xFF0000);			bmp_terrain = new Bitmap(data_terrain, "auto", true);						levelW = c_sprite.width;			levelH = c_sprite.height;						levelScaleW = w / c_sprite.width;			levelScaleH = h / c_sprite.height;							//renderMat.identity();			//renderMat.translate(data_terrain.width / 2, data_terrain.height / 2);						data_terrain.draw(c_sprite, renderMat);// , null, null, null, null, true);						//bmp_terrain.x = -bmp_terrain.width / 4;			//bmp_terrain.y = -bmp_terrain.height / 4;						addChild(bmp_terrain);						changeZoom(1);			center(0,0);			//clearSprite();		}				public function doScroll(dx:Number, dy:Number) {						if (!checkBounds(relScrollX + dx, relScrollY + dy)){				relScrollX += dx;				relScrollY += dy;				updateScroll();			}		}				private function updateScroll() {			//trace("Scroll = (" + relScrollX + "," + relScrollY + ")");			bmp_terrain.scrollRect = new Rectangle(relScrollX,relScrollY,STAGE_W*BUFFER_RATIO, STAGE_H*BUFFER_RATIO);//640*2,480*2);						//trace("CornerX: " + BMPCornerX);			//trace("toAbsX:" + convertToAbsX(relScrollX));			//trace("CornerY: " + BMPCornerY);			//trace("Scale: " + scale);		}				private function updateBMP() {			renderMat.identity();				//var ratio:Number = data_terrain.width / data_terrain.height;			renderMat.scale(levelScaleW, levelScaleH); //accomodate the level size			renderMat.scale(scale, scale);			  //accomodate the zoom		//	renderMat.translate( pixelsW / 2, pixelsH / 2);					//offset(); // Do we need this?				renderMat.translate(BMPCornerX, BMPCornerY);									data_terrain.fillRect(data_terrain.rect, 0x000000);			data_terrain.draw(c_sprite, renderMat);						//trace("CornerX: " + BMPCornerX);			//trace("toAbsX:" + convertToAbsX(relScrollX));			//trace("CornerY: " + BMPCornerY);			//trace("Scale: " + scale);			//trace("LevelScaleW: " + levelScaleW);			//trace("LevelScaleH: " + levelScaleH);		}				public function changeZoom(n:Number) {						var oldRelX:Number = (convertToAbsX(relScrollX) - (STAGE_W * 0.5 / (scale * levelScaleW)))// * (scale * levelScaleW * 0.5);			var oldRelY:Number = (convertToAbsY(relScrollY) - (STAGE_H * 0.5 / (scale * levelScaleH)))// * (scale * levelScaleH * 0.5);			//var oldRelX:Number = relScrollX - (STAGE_W * 0.5);			//var oldRelY:Number = relScrollY - (STAGE_H * 0.5);												//var diff:Number = n - scale;	//get the difference between the new zoom and the old zoom			//diff += 1;			zoom = n;			if (zoom <= 0.1) zoom = 0.1; // constrain to positive			if (zoom >= 5) zoom = 5; // constrain to reasonable zoom						var oldScale:Number = scale;			scale = n*SCALE_MULT;						//store the new zoom						// We need to shift the relative scroll to accomodate for zooming out.			// We have to normalize it first (convert to abs and add half the stage size), then scale by zoom/2.			var newRelX:Number = (convertToAbsX(relScrollX) - (STAGE_W * 0.5 / (scale * levelScaleW)))// * (scale * levelScaleW * 0.5);			var newRelY:Number = (convertToAbsY(relScrollY) - (STAGE_H * 0.5 / (scale * levelScaleH)))// * (scale * levelScaleH * 0.5);			//var newRelX:Number = relScrollX - (STAGE_W * 0.5);			//var newRelY:Number = relScrollY - (STAGE_H * 0.5);						//trace(convertToAbsX(relScrollX) + ", " + convertToAbsY(relScrollY));			//trace("Old: " + oldRelX + ", " + oldRelY);			//trace("New: " + newRelX + ", " + newRelY);						//renderMat.scale(diff, diff);			//pixelsW= c_sprite.width * scale;			//pixelsH = c_sprite.height * scale;						updateBMP();									doScroll((newRelX - oldRelX)*scale/SCALE_MULT, (newRelY - oldRelY)*scale/SCALE_MULT);			//doScroll(-oldRelX * (scale - oldScale) / (scale), -oldRelY * (scale - oldScale) / (scale));					//trace(relScrollX + ", " + relScrollY);			//trace((convertToAbsX(relScrollX) - (STAGE_W * 0.5 / (scale * levelScaleW))) + ", " + (convertToAbsY(relScrollY) - (STAGE_H * 0.5 / (scale * levelScaleH))))			//trace(oldRelX * (scale - oldScale) / scale + ", " + oldRelY * (scale - oldScale) / scale);			//trace(scale);			//trace((newRelX - oldRelX) + ", " + (newRelY - oldRelY));			//trace((newRelX - oldRelX)*scale + ", " + (newRelY - oldRelY)*scale)			//trace(BMPCornerX + ", " + BMPCornerY);			//trace((STAGE_H * 0.5 / (scale * levelScaleH)));			//trace("n = " + n + "scale = " + scale);			//trace("levelScale=" + levelScaleW + "," + levelScaleH);			//trace("pixelsScale=" + pixelsW + "," + pixelsH);					}				// Recenters on (ox, oy) as a quick pop		public function center(ox:Number=0,oy:Number=0) {			// We make ox,oy negative so that 100,100 is 100 pixels down and to the right of 0,0.			var newX:Number = convertToRelX(-ox + STAGE_W/2)			var newY:Number = convertToRelY(-oy + STAGE_H/2)						if (!checkBounds(newX, newY)){				relScrollX = newX;				relScrollY = newY;								updateScroll();			}		}				// Does a smooth, quick scroll to the center (ox, oy)		public function smoothToCenter(ox:Number=0,oy:Number=0) {					}				public function onKeyDown(k:KeyboardEvent) {			var scrollRate:Number = 5;			var zoomRate:Number = 0.05;			switch(k.keyCode) {				case Keyboard.UP: pendingScroll[0] = -scrollRate;  break;				case Keyboard.DOWN: pendingScroll[0] = scrollRate;  break;				case Keyboard.LEFT: pendingScroll[1] = -scrollRate; break;				case Keyboard.RIGHT: pendingScroll[1] = scrollRate;  break;				case 65: pendingZoom = -zoomRate; break;				case 90: pendingZoom = zoomRate; break;				case 67: center(0, 0); break;			}		}				public function onKeyUp(k:KeyboardEvent) {			switch(k.keyCode) {				case Keyboard.UP: pendingScroll[0] = 0;  break;				case Keyboard.DOWN: pendingScroll[0] = 0;  break;				case Keyboard.LEFT: pendingScroll[1] = 0; break;				case Keyboard.RIGHT: pendingScroll[1] = 0;  break;				case 65: pendingZoom = 0; break;				case 90: pendingZoom = 0; break;			}		}				// Checks for any pending zoom / scroll requests, processes them if there are		public function checkPending(e:Event) {			//trace("pendingScroll = " + pendingScroll);			if (pendingScroll[0] != 0 || pendingScroll[1] != 0) {				doScroll(pendingScroll[1], pendingScroll[0]);			}			if (pendingZoom != 0) {				changeZoom(zoom + pendingZoom);			}		}				// Checks to see if we'll over-scroll our buffer and need to redraw our BMP.  Handles it if we will.		// Returns true if we had to change something, false if it's good.  Thus, we check for !checkBounds and		// know we can update our scroll if it's false - otherwise we shouldn't update since checkBounds		// will do it for us.		// (BUFFER_RATIO - 1) is the percent of over-write we do		// newX and newY are the proposed new scroll points for absScrollX/Y		private function checkBounds(newX:Number, newY:Number):Boolean {			var overWriteX:Number = STAGE_W * (BUFFER_RATIO - 1);			var overWriteY:Number = STAGE_H * (BUFFER_RATIO - 1);			//trace ("X: " + relScrollX);			//trace ("Y: " + relScrollY);			//trace(newX - relScrollX);			//trace(newY - relScrollY);			if (newX < 0 || newX > overWriteX || newY < 0 || newY > overWriteY){				//trace("Overwrite");				var newDx:Number = newX - relScrollX;				var newDy:Number = newY - relScrollY;				if (newX < 0){					BMPCornerX += overWriteX * 0.5;					relScrollX += overWriteX * 0.5;				}				else if (newX > overWriteX){					BMPCornerX -= overWriteX * 0.5;					relScrollX -= overWriteX * 0.5;				}				if (newY < 0){					BMPCornerY += overWriteY * 0.5;					relScrollY += overWriteY * 0.5;				}				else if (newY > overWriteY){					BMPCornerY -= overWriteY * 0.5;					relScrollY -= overWriteY * 0.5;				}				doScroll(newDx, newDy);				updateBMP();				//trace("newDx: " + newDx);				//trace("newDy: " + newDy);								return(true);			}			return(false);		}				// Converts an absolute scroll value to one relative to the currently-drawn BMP.		// This includes converting center-of view to top-left of view, meaning that if we're		// lookng at a 640x480 BMP, and we're centered on 330x240, the relative value will be (10,0).		// 		private function convertToRelX(absX:Number):Number{			return (BMPCornerX - (absX * scale * levelScaleW));		}				// Converts an absolute scroll value to one relative to the currently-drawn BMP		private function convertToRelY(absY:Number):Number{			return (BMPCornerY - (absY * scale * levelScaleH));		}				private function convertToAbsX(relX:Number):Number{			return (BMPCornerX - relScrollX)/(scale*levelScaleW);			//return (BMPCornerX - (relScrollX/(scale*levelScaleW)));		}				private function convertToAbsY(relY:Number):Number{			return (BMPCornerY - relScrollY)/(scale*levelScaleH);			//return (BMPCornerY - (relScrollY/(scale*levelScaleH)));		}				private function offset() {						var xo:Number = bmp_terrain.width / 2;	//distance to the center of the canvas			var yo:Number = bmp_terrain.height / 2;			//xo -= (c_sprite.width/2);			//distance to the center of the sprite			//yo -= (c_sprite.height/2);			//resulting values is the distance to move the center of the image			renderMat.translate(xo, yo);		}	}	}