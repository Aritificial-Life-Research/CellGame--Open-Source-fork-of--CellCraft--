package  {	import com.cheezeworld.math.Vector2D;	import com.pecLevel.WaveEntry;	import com.pecSound.SoundLibrary;	import com.woz.WizardOfOz;	import fl.controls.NumericStepper;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import com.pecLevel.EngineEvent;	import SWFStats.*;			/**	 * ...	 * @author Lars A. Doucet	 */	public class Cell extends GameObject	{		//values:				private var volume:Number;				private var gravRadius:Number = 150;		private var gravRadius2:Number = 150 * 150;		//resources:				//THESE ARE NOT FOR REAL USE! THESE ARE JUST HANDY READ REFERENCES FOR SPEED!		public var r_atp:Number = 0;		public var r_na:Number = 0;		public var r_aa:Number = 0;		public var r_fa:Number = 0;		public var r_g:Number = 0;		public var r_max_atp:Number = 1;		public var r_max_na:Number = 1;		public var r_max_aa:Number = 1;		public var r_max_fa:Number = 1;		public var r_max_g:Number = 1;				public var toxin_level:Number = 0;				private var ph_balance:Number = 7.5;		private var cyto_volume:Number = 10;				//pointers:		private var p_director:Director;	//	private var p_engine:Engine;		private var p_canvas:WorldCanvas;	//	private var p_world:World;		private var p_interface:Interface;		private var p_woz:WizardOfOz;				//children:		public var c_nucleus:Nucleus;		public var c_centrosome:Centrosome;		public var c_er:ER;		public var c_membrane:Membrane;		public var c_golgi:Golgi;		public var c_skeleton:Cytoskeleton;				public static var LYSOSOME_STARTED:int = 0;		public static var LYSOSOME_FINISHED:int = 0;		public static var LYSO_RNA_STARTED:int = 0;		public static var LYSO_RNA_FINISHED:int = 0;		public static var LYSO_RIB_STARTED:int = 0;		public static var LYSO_RIB_FINISHED:int = 0;		public static var LYSO_PRO_STARTED:int = 0;		public static var LYSO_PRO_FINISHED:int = 0;		public static var LYSO_VES_STARTED:int = 0;		public static var LYSO_VES_FINISHED:int = 0;		public static var LYSO_GOL_STARTED:int = 0;		public static var LYSO_GOL_FINISHED:int = 0;				public static var RADICALS_ON:Boolean = false;				private var spawning_engine_radicals:Boolean = false;		private var spawn_engine_radical_count:int = 0;		private var spawn_engine_radical_origin:String;		private var spawn_engine_radical_target:String;		private var spawn_engine_radical_counter:int = 0;		private var SPAWN_ENGINE_RADICAL_TIME:int = 30;				//consts:				public static const DEFENSIN_AMOUNT:Number = 1; //1 defensin per vesicle		public static const TOXIN_AMOUNT:Number = 2;		//public static const ATP_CONCENTRATION:Number = 0.000202636; //maximum amount of resource per square pixel		public static const NA_CONCENTRATION:Number = 0.000020264;		public static const AA_CONCENTRATION:Number = 0.000050659;		public static const FA_CONCENTRATION:Number = 0.0000101318; //maximum of about 50 g		public static const G_CONCENTRATION:Number =  0.0000050659; //maximum of about 25 G				public static const MAX_NA:int = 100;		public static const MAX_AA:int = 200 * Costs.AAX		public static const MAX_FA:int = 100;		public static const MAX_G:int = 50;				public static const MAX_ACID_DAMAGE:Number = 15; //maximum X damage per second at 0.0 pH				//lists:		private var list_rna:Vector.<RNA>;		private var list_ribo:Vector.<Ribosome>;		private var list_lyso:Vector.<Lysosome>;		private var list_perox:Vector.<Peroxisome>;		private var list_slicer:Vector.<SlicerEnzyme>;		private var list_dnarepair:Vector.<DNARepairEnzyme>;		private var list_radical:Vector.<FreeRadical>;				private var list_virus:Vector.<Virus>;						private var list_junk:Vector.<CellObject>; //protein globs, etc				private var list_mito:Vector.<Mitochondrion>;		private var list_chlor:Vector.<Chloroplast>;				private var list_ves:Vector.<BlankVesicle>;		private var list_bigves:Vector.<BigVesicle>;				private var list_hardpoint:Vector.<HardPoint>;		//private var list_escortpoint:Vector.<HardPoint>;				private var list_running:Vector.<CellObject>; //objects that need to run()		private var list_selectable:Vector.<CellObject>; //objects that can be selected								private var c_objectGrid:ObjectGrid;		public static var SHOW_GRID:Boolean = false;				private var dirty_selectList:Boolean = false;		private var dirty_units:Boolean = false;				private static const GRID_W:int = 10;		private static const GRID_H:int = 10;				private var clearCount:int = 0;		private const CLEAR_TIME:int = 30;				private var PRODUCE_TIME:int = 60;		private var produceCount:int = 0;				private var NECROSIS_TIME:int = 120;		private var NECROSIS_DMG:int = 6;		private var necrosisCount:int = 0;				public var isCellDying:Boolean = false;				private var mitoCount:int = 0; //how many mitos do we have?		private var chloroCount:int = 0; //how many mitos do we have?		private var canCytoProcess:Boolean = true;		public var canFatProcess:Boolean = true; //please don't change this externally, just use this for easy access				public static const MAX_MITO:int = 10;		public static const MAX_CHLORO:int = 10;		public static const MAX_LYSO:int = 25;		public static const MAX_PEROX:int = 10;		public static const MAX_RIBO:int = 25;		public static const MAX_SLICER:int = 50;		public static const MAX_DNAREPAIR:int = 25;		public static const MAX_DEFENSIN:int = 50;		public static const MAX_TOXIN:int = 100;		//public static const MAX_				//Include the fastmath local function library		include "inc_fastmath.as"				private var lvl_sunlight:Number = 1;		private var lvl_toxins:Number = 0;				public function Cell() 		{			//animateOff();		}				public function init() {			setCentLoc(0, 0);			makeObjectGrid();			setChildren();			makeLists();			addEventListener(RunFrameEvent.RUNFRAME, run);			//addEventListener(MouseEvent.CLICK, click);			addEventListener(MouseEvent.MOUSE_DOWN, mouseDown);		}						public override function destruct() {			p_director = null;			p_engine = null;			p_world = null;	 		p_canvas = null;			p_interface = null;						clearVector(Vector.<GameObject>(list_ribo));			clearVector(Vector.<GameObject>(list_lyso));			clearVector(Vector.<GameObject>(list_perox));			clearVector(Vector.<GameObject>(list_slicer));			clearVector(Vector.<GameObject>(list_dnarepair));			clearVector(Vector.<GameObject>(list_mito));			clearVector(Vector.<GameObject>(list_chlor));			clearVector(Vector.<GameObject>(list_bigves));			clearVector(Vector.<GameObject>(list_ves));			clearVector(Vector.<GameObject>(list_rna));			clearVector(Vector.<GameObject>(list_hardpoint));			clearVector(Vector.<GameObject>(list_running));			clearVector(Vector.<GameObject>(list_selectable));			super.destruct();		}		public function mouseDown(m:MouseEvent) {			//trace("Cell.mouseDown()");						p_engine.cellMouseDown(m);					}				/*public function click(m:MouseEvent) {			if (p_engine.getSelectMode()) {							}else {				//trace("CELL CLICK!");			}		}*/				public function onZoomChange(n:Number) {			for each(var g:GameObject in list_running) {				g.updateBubbleZoom(n);			}		}				public function fauxRun() {			c_membrane.drawAllNodes(); //update the membrane			for each(var b:BigVesicle in list_bigves) {				b.updateBigVesicle();			}			for each(var v:Virus in list_virus) {				if (v.hasVesicle) {					v.drawVesicle();					//v.updateVesicle(null);				}			}		}				public function run(r:RunFrameEvent) {			var i:int = 0;			for each(var g:GameObject in list_running) {				if(g != null){					g.dispatchEvent(r);				}else { //if we come across a null object, remove it from the list					//trace("spliced null object g=" + g + "from list_running");					list_running.splice(i, 1);				}				i++;			}			//checkSituations();			//produceTick();			clearTick();			flush();		}				private function produceTick(r:RunFrameEvent) {			produceCount++;			if (produceCount > PRODUCE_TIME) {				produceCount = 0;				if(mitoCount == 0){  //anaerobic digestion					if (spend([0, 0, 0, 0, 1], new Point(c_centrosome.x+100, c_centrosome.y))) {						produce([2, 0, 0, 0, 0], 1, new Point(c_centrosome.x + 100, c_centrosome.y));					}				}				if(canFatProcess){					tryGtoFA();				}else {					burnExcessG();				}			}		}				public function setResources(atp:int, na:int, aa:int, fa:int, g:int,max_atp:int,max_na:int,max_aa:int,max_fa:int,max_g:int) {			r_max_atp = max_atp;			r_max_na = max_na;			r_max_aa = max_aa;			r_max_fa = max_fa;			r_max_g = max_g;			r_atp = atp;			r_aa = aa;			r_na = na;			r_g = g;			r_fa = fa;		}				/*public function getG() {					}*/				//private function 				private function burnExcessG() {			var diff:int = r_g - r_max_g;			if (diff > 0) {				spend([0,0,0,0,4], new Point(c_centrosome.x+100,c_centrosome.y))			}		}				private function tryGtoFA() {			//var a:Array = p_engine.getResources();			//trace("Cell.tryGtoFA() a = " + a + " r_max_g = " + r_max_g);			if (r_g - r_max_g >= 4) {				if(spend([0, 0, 0, 0, 4], new Point(c_centrosome.x + 100, c_centrosome.y))){					produce([0, 0, 0, 1, 0], 1, new Point(c_centrosome.x + 100, c_centrosome.y));				}			}		}				private function clearTick() {			clearCount++;			if (clearCount > CLEAR_TIME) {				clearCount = 0;				c_objectGrid.clearGrid();				c_membrane.updateGrid();				updateGridThings();				//c_cell.updateGrid();			}		}				private function updateGridThings() {			for each(var m:Mitochondrion in list_mito) {				if (!m.dying) {					m.placeInGrid();				}			}			for each(var c:Chloroplast in list_chlor) {				if (!c.dying) {					c.placeInGrid();				}			}			for each(var h:HardPoint in list_hardpoint) {				h.placeInGrid();			}			for each(var p:Peroxisome in list_perox) {				p.placeInGrid();			}			for each(var l:Lysosome in list_lyso) {				//if(!l.dying){					l.placeInGrid();				//}			}		}				/*public function checkSituations() {					}*/				public function setSunlight(n:Number) {			lvl_sunlight = n;			for each(var c:Chloroplast in list_chlor) {				c.setSunlight(lvl_sunlight);			}		}				public function setToxinLevel(n:Number) {			lvl_toxins = n;		}				public function setFatProcess(yes:Boolean) {			canFatProcess = yes;		}				public function setCytoProcess(yes:Boolean) {			canCytoProcess = yes;			if (yes) {				addEventListener(RunFrameEvent.RUNFRAME, produceTick, false, 0, true);			}else {				removeEventListener(RunFrameEvent.RUNFRAME,produceTick);			}		}						public function flush() {			if (dirty_selectList) {				//trace("p_world = " + p_world);				list_selectable.sort(sortOnNumID); //sort it so the 				var hasMulti:Boolean = false;				for each(var s:Selectable in list_selectable) {	//look for multiselectable units					if (s.getCanSelect() && s.getSingleSelect() == false) {						hasMulti = true;						//trace("Cell.flush() : found multiselect unit: " + s);						break;					}				}				p_engine.setMultiSelectMode(hasMulti); //notify the engine so we can disable the multi-selecter if need be				if(p_world){					p_world.updateSelectList();				}				dirty_selectList = false;			}			if (dirty_units) {				dirty_units = false;				onPHChange(); //update new units				onUnitChange();			}		}				public function setChildren() {			//try{				c_centrosome.setCell(this);				c_er.setCell(this);				c_golgi.setCell(this);				c_nucleus.setCell(this);												setupMembrane();				setupSkeleton();							//}catch (e:Error) {				//trace("ERORR @ Cell.setChildren: one of the children was undefined");			//}					}				private function setupMembrane() {			c_membrane.setCell(this);			c_membrane.setCent(c_centrosome);			c_membrane.setSkeleton(c_skeleton);			c_membrane.setObjectGrid(c_objectGrid);			c_membrane.init();			c_membrane.setCanvasGrid(p_canvas.c_cgrid);			p_engine.updateMaxResources();		}				public function buyToxin() {			var cost:Array = Costs.getMAKE_TOXIN(1);			spend(cost);			p_engine.notifyOHandler(EngineEvent.EXECUTE_ACTION, "null", "make_toxin", 1);						generateToxin(cost[1]);		}				public function buyDefensin() {			if(Director.STATS_ON){Log.LevelAverageMetric("cell_buy_defensin", Director.level, 1);}			var cost:Array = Costs.getMAKE_DEFENSIN(1);			spend(cost);			p_engine.notifyOHandler(EngineEvent.EXECUTE_ACTION, "null", "make_defensin", 1);			generateDefensin(cost[1]);		}				public function sellDefensin():int {			//cheap hack that finds the membrane in the lower right quadrant, where defensin vesicles			//usually go to merge			if(c_membrane.getDefensins() > 0){				var mnode:MembraneNode = c_membrane.findClosestMembraneNode(c_golgi.x, c_golgi.y);				var p:Point = new Point(mnode.x, mnode.y);				//end cheap hack				var atpCost:int = Costs.SELL_DEFENSIN[0];				if (spendATP(atpCost, p)) {					c_membrane.removeDefensin(1);					Director.startSFX(SoundLibrary.SFX_POP2);					refundDefensin(p);					if(Director.STATS_ON){Log.LevelAverageMetric("cell_sell_defensin", Director.level, 1);}					p_engine.notifyOHandler(EngineEvent.EXECUTE_ACTION, "null", "take_defensin", 1);								return FailCode.SUCCESS;				}else {					p_engine.showImmediateAlert(Messages.A_NO_AFFORD_RECYCLE);					return FailCode.CANT_AFFORD;				}			}else {				p_engine.showImmediateAlert("You don't have any defensins to recycle!");			}			return FailCode.TOTAL_FAIL;		}				public function sellMembrane():int {			if (Membrane.CURR_NODES > Membrane.STARTING_NODES) {				//refundMembrane();				if (takeMembrane()) {					//cheap hack that finds the membrane in the lower left quadrant, where membrane vesicles					//usually go to merge					var mnode:MembraneNode = c_membrane.findClosestMembraneNode(cent_x - 50, cent_y - 50);					var p:Point = new Point(mnode.x, mnode.y);					//end cheap hack					var atpCost:int = Costs.SELL_MEMBRANE[0];					if(spendATP(atpCost,p)){						refundMembrane(p);						if(Director.STATS_ON){Log.LevelAverageMetric("cell_sell_membrane", Director.level, 1);}						p_engine.notifyOHandler(EngineEvent.EXECUTE_ACTION, "null", "take_membrane", 1);								}else {						p_engine.showImmediateAlert(Messages.A_NO_AFFORD_RECYCLE);					}					return FailCode.SUCCESS;				}			}else {				p_engine.showImmediateAlert("Your membrane is at the minimum size already!");			}			return FailCode.TOTAL_FAIL;		}				public function buyMembrane() {			if(Membrane.CURR_NODES < Membrane.MAX_NODES){				var ex:Number = c_er.x + c_er.exit23.x;				var ey:Number = c_er.y + c_er.exit23.y;				var cost:Array = Costs.getMAKE_MEMBRANE(1);				spend(cost);// , new Point(ex, ey), 1, 0, false, true);				if(Director.STATS_ON){Log.LevelAverageMetric("cell_buy_membrane", Director.level, 1);}				p_engine.notifyOHandler(EngineEvent.EXECUTE_ACTION, "null", "make_membrane", 1);				generateMembrane(cost[1]);			}else {				p_engine.showImmediateAlert("Can't expand! Membrane is at maximum size!");			}			//makeMembrane();		}				public function refundDefensin(p:Point) {			var cost:Array = Costs.SELL_DEFENSIN.concat();			cost[0] = 0;			produce(cost, 1, p);		}				public function refundMembrane(p:Point) {			var cost:Array = Costs.SELL_MEMBRANE.concat();			//spendATP(cost[0]);			cost[0] = 0;			produce(cost, 1, p);		}						public function takeMembrane():Boolean {			if(c_membrane.canTakeMembrane()){				if(Membrane.CURR_NODES > Membrane.STARTING_NODES){					Director.startSFX(SoundLibrary.SFX_ABSORB);					p_engine.notifyOHandler(EngineEvent.ENGINE_TRIGGER, "shrink_membrane", "null", 1);					//p_engine.notifyOHandler(EngineEvent.EXECUTE_ACTION, "null", "make_membrane", 1);					c_membrane.removeMembraneNodes(1,true);					//c_membrane.deleteMembraneNode(;					//c_membrane.addMembraneNode();					updateStartHardPoints();					//c_skeleton.updateGravityPoints();					p_engine.updateMaxResources();					return true;				}else {					p_engine.showImmediateAlert("Can't shrink! Membrane is at minimum size!");					return false;				}			}else {				trace("Cell.takeMembrane(): Hang on a sec, bro!");				return false;				}		}								public function makeMembrane(p:Point=null) {			if(Membrane.CURR_NODES < Membrane.MAX_NODES){				Director.startSFX(SoundLibrary.SFX_ABSORB);				p_engine.notifyOHandler(EngineEvent.ENGINE_TRIGGER, "expand_membrane", "null", 1);				//p_engine.notifyOHandler(EngineEvent.EXECUTE_ACTION, "null", "make_membrane", 1);				c_membrane.addMembraneNode();				updateStartHardPoints();				//c_skeleton.updateGravityPoints();				p_engine.updateMaxResources();			}else {				p_engine.showImmediateAlert("Membrane at maximum size; vesicle recycled!");				refundMembrane(p);				c_membrane.readyForVesicle();			}		}		public function updateMembrane() {			c_skeleton.updateGravityPoints();		}						private function setupSkeleton() {			c_skeleton.setCell(this);			c_skeleton.setCent(c_centrosome);			c_skeleton.setEngine(p_engine);			c_skeleton.setNucleus(c_nucleus);			c_skeleton.setMembrane(c_membrane);			c_skeleton.init();			setChildIndex(c_skeleton, getChildIndex(c_centrosome) - 1);		}		public function onSkeletonReady() {			c_membrane.onSkeletonReady();		}				public function makeMembraneVesicle(t:TransportVesicle,r:Number) {			var v:BigVesicle = makeBigVesicle();			v.x = t.x;			v.y = t.y;			v.setProduct(t.getProduct());			v.instantGrow(r);			t.setBigVesicle(v);			swapChildren(v, t); //make v under t		}				private function growBigVesicleFor(c:CellObject):BigVesicle{			var v:BigVesicle = makeBigVesicle();			v.x = c.x;			v.y = c.y;			v.setPH(ph_balance);			v.startDigestGrow(c);			swapChildren(v, c); //make v under s			return v;		}				public function onFinishDigestGrow(v:BigVesicle) {				}				public function countThing(str:String):int {			if (str == "lysososome") {return list_lyso.length;}			else if (str == "ribosome") {return list_ribo.length;}			else if (str == "slicer") {return list_slicer.length;}			else if (str == "peroxisome") {return list_perox.length;}			else if (str == "mitochondrion") {return list_mito.length;}			else if (str == "chloroplast") {return list_chlor.length;}			else if (str == "dnarepair") {return list_dnarepair.length;}			else if (str == "freeradical") { return list_radical.length; }			else if (str == "rna") { return checkRNACount(); }			else if (str == "evil_rna") { return checkEvilRNACount(""); }			return 0;		}				/*public function lysosomeEatSomething(s:Selectable):Boolean {			var l:Lysosome = findClosestLysosome(s.x, s.y);			if (l) {				s.targetForEating();				return l.eatSomething(s);			}						//if we got here, we failed						if(list_lyso.length < 1){ //if we have no lysosomes				p_engine.showAlert(Messages.A_NO_LYSO_R); //Alert that we need lysosomes for recyclnig			}						return false;		}*/						private function makeStartBigVesicle() {			var v:BigVesicle = makeBigVesicle();			v.x = -50;			v.y = 200;		}		public function instantSlicer(xx:Number, yy:Number, notifyEngine:Boolean = true):SlicerEnzyme {			var s:SlicerEnzyme = makeSlicer(true);			//s.x = xx;			//s.y = yy;						if (notifyEngine)				p_engine.startAndFinishSlicer();			return s;		}				public function instantRibosome(xx:Number, yy:Number,notifyEngine:Boolean=true):Ribosome{			var r:Ribosome = makeRibosome(true);			//r.x = xx;			//r.y = yy;						if(notifyEngine)				p_engine.startAndFinishRibosome();			return r;		}				private function makeStartHardPoints() {			var v:Vector.<GravPoint> = c_skeleton.newWarblePoints();			var i:int = 0;			for each(var g:GravPoint in v) {				var h:HardPoint = makeHardPoint();				h.x = g.x;				h.y = g.y;				h.setRadius(g.radius*0.9); //this is to avoid a rare bug where the cell membrane explodes on startup				h.rememberRadius();				if (i % 2 == 0) {					h.warble_sign *= -1;				}				h.startWarble();				h.updateLoc();				i++;			}		}				private function updateStartHardPoints() {						var v:Vector.<GravPoint> = c_skeleton.newWarblePoints();			var i:int = 0;			for each(var h:HardPoint in list_hardpoint) {				if (h.isWarble) {					//h.setNewPos(v[i].x+cent_x, v[i].y+cent_y);					h.x = v[i].x + cent_x;					h.y = v[i].y + cent_y;					h.setNewRadius(v[i].radius * 0.9);					h.resetWarble();					//h.setRadius(v[i].radius * 0.9);					//h.rememberRadius();					h.updateLoc();					i++;				}			}		}				private function makeStartSlicers(n:int) {			//var c:Vector.<Number> = circlePointsOffset(230,n,0,0);			var i:int = 0;			for (i = 0; i < n; i++) {				var s:SlicerEnzyme = instantSlicer(0, 0);				s.clip.gotoAndPlay(i); //offset their animations so it looks nice; HACK			}		}				private function makeStartLysosomes(n:int) {			var c:Vector.<Number> = circlePointsOffset(230, n, 0, 0);			var i:int = 0;			for (i = 0; i < n; i++) {				p_engine.startAndFinishLysosome();				var l:Lysosome = instantLysosome(0, 0,false);				l.deployGolgi(true);				l.clip.clip.gotoAndPlay(i); //offset their animations so it looks nice; HACK			}		}				private function makeStartPeroxisomes(n:int) {			var c:Vector.<Number> = circlePointsOffset(230, n, 0, 0);			var i:int = 0;			for (i = 0; i < n; i++) {				p_engine.startAndFinishPeroxisome();				var p:Peroxisome = instantPeroxisome(0, 0,false);				p.deployGolgi(true);				p.isBusy = false; //HACK HACK HACK				p.is_active = true;				p.clip.clip.gotoAndPlay(i); //offset their animations so it looks nice; HACK			}		}				private function makeStartRibosomes(n:int) {			var c:Vector.<Number> = circlePointsOffset(230, n, 0, 0);			var i:int = 0;			for (i = 0; i < n; i++) {				var r:Ribosome = instantRibosome(0,0);				r.ribosomeDeploy(true);				r.clip.clip.gotoAndPlay(i); //offset their animations so it looks nice; HACK			}		}				private function makeStartMitochondria(n:int) {			var c:Vector.<Number> = Vector.<Number>([-50, -200, -150, -200,50,-200]);			for (var i:int = 0; i < n; i++) {				var m:Mitochondrion = makeMitochondrion();				m.x = c[i * 2];				m.y = c[i * 2 + 1];// + c_nucleus.y ;			}		}				private function makeStartChloroplasts(n:int) {			var c:Vector.<Number> = Vector.<Number>([-50,200,-150,200,50,200]);			for (var i:int = 0; i < n; i++) {				var cl:Chloroplast = makeChloroplast();				cl.x = c[i * 2];// + c_nucleus.x;				cl.y = c[i * 2 + 1];// + c_nucleus.y;			}		}				private function makeSkeleton() {			var list:Vector.<CellObject> = new Vector.<CellObject>;			var done:Boolean = false;			/*for each(var m:Mitochondrion in list_mito) {				list.push(m);			}			for each(var c:Chloroplast in list_chlor) {				list.push(c);			}*/			//list.push(c_nucleus);			//list.push(c_golgi);			list.push(c_centrosome);			//list.push(c_er);			c_skeleton.makeTubes(list);			addRunning(c_skeleton);		}				private function makeTestMitochondria(n:int) {			var c:Vector.<Number> = circlePointsOffset(300, n, 0,0);			for (var i:int = 0; i < n; i++) {				var m:Mitochondrion = makeMitochondrion();				m.x = c[i * 2] ;				m.y = c[i * 2 + 1] ;			}		}				private function makeTestLysosomes(n:int) {			var c:Vector.<Number> = circlePointsOffset(250, n,0,0);			for (var i:int = 0; i < n; i++) {				instantLysosome(c[i * 2], c[i * 2 + 1]);				//var l:Lysosome = growLysosome(c[i * 2],c[i * 2 + 1]);				//l.is_active = true;			}		}				private function makeTestChloroplasts(n:int) {			var c:Vector.<Number> = circlePointsOffset(280, n,0,0);			for (var i:int = 0; i < n; i++) {				var l:Chloroplast = makeChloroplast();				l.x = c[i * 2];				l.y = c[i * 2 + 1];			}		}				private function makeTestRibosomes(n:int) {			var c:Vector.<Number> = circlePointsOffset(230, n,0,0);			for (var i:int = 0; i < n; i++) {				var r:Ribosome = makeRibosome();				r.x = c[i*2];				r.y = c[i * 2 + 1];			}		}				/**		 * Clears a vector of all its variables, and removes them from the display list, if possible		 * @param	v		 */				private function clearVector(v:Vector.<GameObject>) {			for each(var g:GameObject in v){				if (g && (getChildByName(g.name) == g)) { //make sure that it exists and is my child					removeChild(g);					g.destruct();				}				g = null;			}		}				public function setCanvas(c:WorldCanvas) {			p_canvas = c;		}				public function setDirector(d:Director) {			p_director = d;		}				public function receiveWoz(w:WizardOfOz) {			p_woz = w;		}				public override function setEngine(e:Engine) {			p_engine = e;			c_membrane.setEngine(p_engine);		}				public override function setWorld(w:World) {			p_world = w;		}				public function setInterface(i:Interface) {			p_interface = i;		}				public override function getCircleVolume():Number {			return c_membrane.getCircleVolume();		}				/*************************/				private function makeObjectGrid() {			//trace("Cell.makeObjectGrid()");			c_objectGrid = new ObjectGrid();			var size:Number = Membrane.STARTING_RADIUS * 2;			c_objectGrid.makeGrid(GRID_W, GRID_H, size, size);			GameObject.setGrid(c_objectGrid);		}				public function makeLists() {			list_chlor = new Vector.<Chloroplast>;			list_lyso = new Vector.<Lysosome>;			list_mito = new Vector.<Mitochondrion>;			list_virus = new Vector.<Virus>;			list_junk = new Vector.<CellObject>;			list_perox = new Vector.<Peroxisome>;			list_ribo = new Vector.<Ribosome>;			list_slicer = new Vector.<SlicerEnzyme>;			list_dnarepair = new Vector.<DNARepairEnzyme>;			list_radical = new Vector.<FreeRadical>;			list_bigves = new Vector.<BigVesicle>;			list_ves = new Vector.<BlankVesicle>;			list_rna = new Vector.<RNA>;			list_hardpoint = new Vector.<HardPoint>;								makeRunningList();			makeSelectableList();			makeStartSlicers(p_engine.lvl.levelData.start_slicers);			makeStartRibosomes(p_engine.lvl.levelData.start_ribos);			makeStartMitochondria(p_engine.lvl.levelData.start_mitos);			makeStartChloroplasts(p_engine.lvl.levelData.start_chloros);			makeStartPeroxisomes(p_engine.lvl.levelData.start_peroxs);			makeStartLysosomes(p_engine.lvl.levelData.start_lysos);			makeStartHardPoints();						//testPopVesicle();						//makeStartMitochondria(2);			//makeStartChloroplasts(1);						makeSkeleton();								}				public function makeRunningList() {			list_running = new Vector.<CellObject>;						addRunningList(Vector.<CellObject>(list_chlor));			addRunningList(Vector.<CellObject>(list_lyso));			addRunningList(Vector.<CellObject>(list_mito));			addRunningList(Vector.<CellObject>(list_perox));			addRunningList(Vector.<CellObject>(list_ribo));			addRunningList(Vector.<CellObject>(list_slicer));			addRunningList(Vector.<CellObject>(list_radical));			addRunningList(Vector.<CellObject>(list_bigves));			addRunningList(Vector.<CellObject>(list_ves));			addRunningList(Vector.<CellObject>(list_hardpoint));			//Other lists aren't included here, generally this is okay because these things (dna repair) etc aren't spawned			//at the beginning of the game. If I ever decide to do that, I'll have to make sure to include them here			//or starting units of that type won't work!						addRunning(c_nucleus);			addRunning(c_golgi);			addRunning(c_er);			addRunning(c_centrosome);			addRunning(c_membrane);		}				public function makeSelectableList() {			list_selectable = new Vector.<CellObject>;						addSelectableList(Vector.<CellObject>(list_chlor));			addSelectableList(Vector.<CellObject>(list_lyso));			addSelectableList(Vector.<CellObject>(list_mito));			addSelectableList(Vector.<CellObject>(list_perox));			addSelectableList(Vector.<CellObject>(list_ribo));			addSelectableList(Vector.<CellObject>(list_bigves));			addSelectableList(Vector.<CellObject>(list_ves));						addSelectable(c_nucleus);			addSelectable(c_golgi);			addSelectable(c_er);			addSelectable(c_centrosome);			addSelectable(c_membrane);		}				public function addRunningList(v:Vector.<CellObject>) {			for each(var i:CellObject in Vector.<CellObject>(v)) {				list_running.push(i);			}		}				public function addSelectableList(v:Vector.<CellObject>) {			for each(var i:CellObject in Vector.<CellObject>(v)) {				list_selectable.push(i);			}			dirty_selectList = true;		}				public function sortOnNumID(a:Selectable,b:Selectable):int {			if (a.num_id > b.num_id) {				return 1;			}else if (a.num_id < b.num_id) {				return -1;			}else {				return 0;			}		}				public function getSelectables():Vector.<Selectable> {			return Vector.<Selectable>(list_selectable);		}				private function addSelectable(s:Selectable) {			if (s) {				list_selectable.push(s);				dirty_selectList = true; //let the cell know it needs to flush the select list next frame			}		}				private function addRunning(c:CellObject) {			if (c) {				list_running.push(c);			}		}				/*************************/				public function updateSelected() {			p_engine.updateSelected();					}				/**		 * Called by the selected thing, causes the engine to select it and unselect all else		 * @param	c		 */				public function selectOne(c:Selectable, xx:Number, yy:Number) {			//trace("Cell.selectOne() " + c);			if(p_engine.getSelectMode() == true){				p_engine.selectOne(c, xx, yy);			}		}				/**		 * Called by the selected thing, causes the engine to add this to the selected list		 * @param	c		 */				public function selectMany(c:Selectable,finish:Boolean=false) {			//trace("Cell.selectMany() " + c);			if(p_engine.getSelectMode() == true){				p_engine.selectMany(c,finish);			}		}						public function setSelectType(n:int) {			p_engine.setSelectType(n);		}				/*************************/				public override function pauseAnimate(yes:Boolean) {			for each (var c:CellObject in list_running) {				c.pauseAnimate(yes);			}		}				public override function animateOn() {			listsAnimate(true);		}			public override function animateOff() {			listsAnimate(false);		}				private function listsAnimate(yes:Boolean) {			for each (var c:CellObject in list_running) {				if (yes) {					c.animateOn(); 				}else {					c.animateOff();				}			}			}				public function onTopOf(thing1:CellObject, thing2:CellObject,superTop:Boolean=false) {			try{				var t1:int = getChildIndex(thing1);				var t2:int = getChildIndex(thing2);			}catch (e:Error) {				return;			}			if (superTop) { //make them at the top of EVERYTHING				setChildIndex(thing2, numChildren - 1);				swapChildren(thing1, thing2);			}else{				if (t1 < t2) {					swapChildren(thing1, thing2);				}			}			//setChildIndex(thing1, getChildIndex(thing2)+1);			//put thing1 on top of thing2		}						public function spendATP(i:Number, p:Point=null,speed:Number=1,offset:int=0,scaleMode:Boolean=true):Boolean {			if (p) {				p_canvas.justShowMeTheMoney("atp", -i, p.x, p.y, speed, offset, scaleMode);			}			return p_engine.spendATP(i);		}				public function zeroResources() {			p_engine.zeroResources();		}				public function loseResources(a:Array) {			p_engine.loseResources(a);		}						/**		 * 		 * @param	a Array of resources to spend. [ATP,NA,AA,FA,G]		 * @param	p Position to display. Won't show anything if not given.		 * @param	speed How fast the displayed icon moves		 * @param	offset How many icon heights to offset		 * @param	scaleMode Whether it scales with zoom or not		 * @return Whether the user could afford the spend		 */				public function spend(a:Array,p:Point=null,speed:Number=1,offset:int=0,scaleMode:Boolean=true,playSound:Boolean=false):Boolean {			if (p) {				var b:Array = a.concat();				var length:int = b.length;				var numNotZero:int = 0;				for (var i:int = 0; i < length; i++) {					if (b[i] > 0) {						numNotZero++;					}					b[i] *= -1;				}				//trace("Cell.spend() : " + a + " numNotZero=" + numNotZero);			}			var success:Boolean = p_engine.spend(a);			if(success){				if(playSound){					if (numNotZero > 1) {						Director.startSFX(SoundLibrary.SFX_DRAIN);		//if we only spent 1, normal sound					}else {						Director.startSFX(SoundLibrary.SFX_MULTI_DRAIN); //if we spent several, multiple drain sound					}				}				if(p){					p_canvas.justShowMeTheMoneyArray(b, p.x, p.y, speed, offset, scaleMode);				}			}			return success;		}								public function rewardProduce(a:Array, mult:Number, p:Point = null, speed:Number = 1, offset:Number = 0):Boolean {			var length:int = a.length;			for (var i:int = 0; i < length; i++) {				a[i] *= mult;			}			if(p){				p_canvas.justShowMeTheMoneyArray(a, p.x, p.y,speed,offset,false);			}			return p_engine.produce(a);		}				public function produceHeat(amount:Number, mult:Number, p:Point = null, speed:Number = 1, offset:Number = 0) {						if (p) {				p_canvas.justShowMeTheMoney("fire", amount, p.x, p.y, speed, offset);			}			p_engine.changeTemperature(amount);		}				public function produce(a:Array,mult:Number,p:Point=null,speed:Number=1,offset:Number=0):Boolean {			var length:int = a.length;			for (var i:int = 0; i < length; i++) {				a[i] *= mult;			}			if(p){				p_canvas.justShowMeTheMoneyArray(a, p.x, p.y,speed,offset);			}			return p_engine.produce(a);		}				public function getSunlight():Number {			return lvl_sunlight;		}				/**Organelle making functions****/				public function onHalfPlop(c:CellObject) {			setChildIndex(c, c.plopDepth);			p_engine.notifyOHandler(EngineEvent.ENGINE_TRIGGER, "halfplop_organelle", c.text_id, 1);		}				public function onPlop(c:CellObject) {						p_engine.notifyOHandler(EngineEvent.ENGINE_TRIGGER, "plop_organelle", c.text_id, 1);		}				public function onRadicalHit(c:CellObject) {			p_engine.notifyOHandler(EngineEvent.ENGINE_TRIGGER, "radical_damage", c.text_id, 1);		}				public function setRadicals(b:Boolean) {			//trace("Cell.setRadicals(" + b + ")");			for each(var m:Mitochondrion in list_mito) {				m.setRadicals(b);			}			for each(var c:Chloroplast in list_chlor) {				c.setRadicals(b);			}			RADICALS_ON = b;		}				public function notifyOHandler(mainType:String,evType:String,targetType:String,targNum:Number) {			p_engine.notifyOHandler(mainType, evType, targetType, targNum);		}				private function onKill(str:String, amount:int) {			p_engine.notifyOHandler(EngineEvent.THING_DESTROY, "null", str, 1);			p_engine.notifyOHandler(EngineEvent.THING_CHANGE, "null", str, amount);		}				private function onMake(str:String,amount:int) {			dirty_units = true;			p_engine.notifyOHandler(EngineEvent.THING_CREATE, "null", str, 1);			p_engine.notifyOHandler(EngineEvent.THING_CHANGE, "null", str, amount);		}				public function plopOrganelle(str:String) {			//trace("Cell.plopOrganelle() " + str);						var c:CellObject = hideOrganelle(str, false);			c.plopDepth = getChildIndex(c);			c.playAnim("plop");			setChildIndex(c, numChildren - 1);		}						public function hideOrganelle(str:String,yes:Boolean):CellObject {			var toHide:CellObject;			if (str == "nucleus") {				toHide = c_nucleus;			}else if (str == "golgi") {				toHide = c_golgi;			}else if (str == "centrosome") {				toHide = c_centrosome;			}else if (str == "er") {				toHide = c_er;			}			if(yes){				toHide.hideOrganelle();			}else {				toHide.showOrganelle();			}			return toHide;		}						public function onFinishDefensin() {			onMake("defensin", c_membrane.getDefensins());		}				public function makeToxin(xx:Number, yy:Number) {			toxin_level += TOXIN_AMOUNT;			Director.startSFX(SoundLibrary.SFX_TOXIN);			showToxinSpot(TOXIN_AMOUNT, xx, yy);			onMake("toxin", toxin_level);			p_engine.setToxinLevel(toxin_level / MAX_TOXIN);		}				private function makeChloroplast():Chloroplast{			var c:Chloroplast= new Chloroplast();			addChild(c);			c.setCell(this);			list_chlor.push(c);			chloroCount = list_chlor.length;			p_engine.setChloroCount(chloroCount);			addRunning(c);			addSelectable(c);			c.setSunlight(lvl_sunlight);			onMake("chloroplast",list_chlor.length);			return c;		}				public function makeVesicleContent(str:String,xx:Number,yy:Number) {			Director.startSFX(SoundLibrary.SFX_ABSORB);						if (str == "mitochondrion") {				placeVesicleMito(xx, yy);				//placeMitochondrion(xx, yy,true);			}else if (str == "mitochondrion_dead") {				placeVesicleMito(xx, yy, false);				//placeMitochondrion(xx, yy, true, false);			}else if (str == "protein_glob") {				placeProteinGlob(xx, yy);			}else if (str == "chloroplast") {				placeVesicleChloro(xx, yy);			}else if (str == "chloroplast_dead") {				placeVesicleChloro(xx, yy, false);			}			updateMembrane();		}								public function placeProteinGlob(xx:Number, yy:Number) {			var p:ProteinGlob = makeProteinGlob();			p.x = xx;			p.y = yy;			makeEscortPoint(p);			//c_skeleton.makeNewTube(p);		}				public function placeVesicleChloro(xx:Number, yy:Number, isAlive:Boolean = true) {			var c:Chloroplast = placeChloroplast(xx, yy, true, isAlive);			c.setOutsideCell(true);			makeEscortPoint(c);		}				public function placeVesicleMito(xx:Number, yy:Number, isAlive:Boolean = true) {			var m:Mitochondrion = placeMitochondrion(xx, yy, true, isAlive);			m.setOutsideCell(true);			makeEscortPoint(m);			//updateMembrane();					}				public function placeChloroplast(xx:Number, yy:Number, deploy:Boolean=false,isAlive:Boolean=true,nudge:Boolean=true):Chloroplast {			var c:Chloroplast = makeChloroplast();			c.x = xx;			c.y = yy;							c_skeleton.makeNewTube(c);			if (nudge) {				var v:Vector2D = new Vector2D(xx - cent_x, yy - cent_y); //get the vector from the centrosome to this thing				v.normalize();											 //unit vector				v.multiply(0.75 * c_skeleton.cent_radius);				 //multiply by the X * cell's min radius				c.moveToPoint(new Point(cent_x + v.x, cent_y + v.y), FLOAT, true); //move to a comfortable spot in the cell			}			if (!isAlive) {				c.instantSetHealth(10); //very low health			}			return c;		}				public function placeMitochondrion(xx:Number,yy:Number,deploy:Boolean=false,isAlive:Boolean = true,nudge:Boolean=true):Mitochondrion {			var m:Mitochondrion = makeMitochondrion();			m.x = xx;			m.y = yy;			c_skeleton.makeNewTube(m);			//var r:Number = c_skeleton.cent_radius;			if(nudge){				var v:Vector2D = new Vector2D(xx - cent_x, yy - cent_y); //get the vector from the centrosome to this thing				v.normalize();											 //unit vector				v.multiply(0.75 * c_skeleton.cent_radius);				 //multiply by the X * cell's min radius				m.moveToPoint(new Point(cent_x + v.x, cent_y + v.y), FLOAT, true); //move to a comfortable spot in the cell			}			if (!isAlive) {				m.instantSetHealth(10); //very low health			}			return m;			//m.deployCytoplasm(cent_x + v.x,cent_y+v.y,		}				public function getVacList():Vector.<BigVesicle> {			return list_bigves.concat();		}				public function export_makeVirus(type:String):Virus {			var v:Virus;			if (type == "virus_injector") v = new VirusInjector();			else if (type == "virus_invader") v = new VirusInvader();			else if (type == "virus_infester") v = new VirusInfester();			v.setCanvas(p_canvas);			v.setCell(this);			v.init();			return v;		}				public function testPopVesicle() {			//var v:PopVesicle = makePopVesicle(100,200,200);		}						public function makeSplashBurst(size:Number,xx:Number,yy:Number,iteration:int=1,vec:Vector2D=null):SplashBurst {			//trace("Cell.makeSplashBurst() size=" + size + " loc = ("+xx+","+yy+")");			var v:SplashBurst = new SplashBurst();			v.x = xx;			v.y = yy;								v.width = size;  			v.height = size; 			v.rotation = Math.random() * 360;			v.setCell(this);			v.init();			addChild(v);			addRunning(v);			v.startPopping();			setChildIndex(v, 1);			return v;			/*var v:PopVesicle = new PopVesicle(size,iteration);			addChild(v);			setChildIndex(v, 1); //make them underneath everything			v.setCell(this);			list_bigves.push(v);			addSelectable(v);			addRunning(v);			v.x = xx;			v.y = yy;			if(vec){				v.startPopping(vec);			}else {				v.startPopping(new Vector2D(0.5 - Math.random(),0.5 - Math.random()));			}			return v;*/		}				public function popSplashBurst(p:SplashBurst) {			/*//trace("Cell.popVesicle p=" + this + " radius=" + p.popRadius + " it = " + p.iteration);			var times:int = 3;			var rand:Number = Math.random();			if (rand > 0.6) {				times++;			}									var radius:Number = p.popRadius;			var newRadius:Number = radius*1.5 / times;			var v:Vector2D = new Vector2D(newRadius * 2, 0);			v.rotateVector(Math.random() * Math.PI * 2);			var angle:Number = Math.PI * 2 / times;						//trace("Cell.popVesicle newRadius=" + newRadius + " times= " + times);						if(p.iteration < 4){	//if it gets too recursive, don't make any new bubbles				if(newRadius > 15){	//if it gets too small, don't make any new bubbles							for (var i:int = 0; i < times; i++) {						var vnorm:Vector2D = v.getNormalized();						var s:SplashBurst = makeSplashBurst(newRadius, v.x + p.x, v.y + p.y, p.iteration + 1, vnorm);						//var pp:PopVesicle = makePopVesicle(newRadius,v.x+p.x,v.y+p.y,p.iteration+1,vnorm);						v.rotateVector(angle);					}				}			}						killSplashBurst(p);*/		}				public function export_makeBigVesicle(size:Number):BigVesicle {			var v:BigVesicle = new BigVesicle(size);			v.setCell(this);			return v;		}				private function makeBigVesicle():BigVesicle {			var v:BigVesicle = new BigVesicle();			addChild(v);			v.setCell(this);			list_bigves.push(v);			addSelectable(v);			addRunning(v);			//c_membrane.updateVacList();			onMake("big_vesicle",list_bigves.length);			return v;		}				public function spawnRibosomeDNARepair(r:Ribosome, count:int = 1) {			var d:DNARepairEnzyme = makeDNARepair();			var SIZE:Number = 25;			for (var i:int = 0; i < count; i++) {				d.x = r.x + (Math.random() * SIZE) - SIZE / 2;				d.y = r.y + (Math.random() * SIZE) - SIZE / 2;			}			d.init();			p_engine.finishDNARepair();		}				public function spawnRibosomeSlicer(r:Ribosome, count:int = 1) {			var s:SlicerEnzyme = makeSlicer();			var SIZE:Number = 25;			for (var i:int = 0; i < count; i++) {				s.x = r.x + (Math.random() * SIZE)-SIZE/2;				s.y = r.y + (Math.random() * SIZE)-SIZE/2;			}			s.init();			p_engine.finishSlicer();		}				public function spawnRibosomeVirus(r:Ribosome, product:int, count:int=1, wave_id:String="",doesVesicle:Boolean=false) {			var success_count:int = 0;			var v:String;			var type:String;			switch(product) {				case Selectable.VIRUS_INJECTOR: v = "virus_injector"; type = "injector";  break;				case Selectable.VIRUS_INVADER: v = "virus_invader"; type = "invader";  break;				case Selectable.VIRUS_INFESTER: v = "virus_infester"; type = "infester"; break;			}			var success:Boolean = false;			for (var i:int = 0; i < count; i++) {				var SIZE:Number = 20;				var xx:Number = (Math.random() * SIZE)-(SIZE/2);				var yy:Number = (Math.random() * SIZE)-(SIZE/2);				var vi:Virus = makeVirus(v, r.x + xx, r.y + yy, true, true);				if (vi) {					vi.setVesicle(doesVesicle);					vi.wave_id = wave_id;					//trace("Cell.spawnRibosomeVirus() wave_id=" + vi.wave_id);					success = true;					success_count++;				}			}			if (success) { //only play the sound if we succeeded in making a virus				p_engine.makeVirus(type,wave_id, success_count);				Director.startSFX(SoundLibrary.SFX_VIRUS_RISE); //play the sound here so it's not played multiple times per spawn			}		}				public function engineSpawnRadical(count:int, origin:String, target:String, delay:int) {			spawn_engine_radical_count = count;			spawn_engine_radical_origin = origin;			spawn_engine_radical_target = target;			SPAWN_ENGINE_RADICAL_TIME = delay;			if (!spawning_engine_radicals) {				addEventListener(RunFrameEvent.RUNFRAME, onEngineSpawnRadical, false, 0, true);			}		}				private function onEngineSpawnRadical(r:RunFrameEvent) {			spawn_engine_radical_counter++;			if (spawn_engine_radical_counter >= SPAWN_ENGINE_RADICAL_TIME) {				spawn_engine_radical_counter = 0;				removeEventListener(RunFrameEvent.RUNFRAME, onEngineSpawnRadical);				var maker:CellObject = null;				if (spawn_engine_radical_origin == "mitochondrion") {					maker = getRandomMito();				}else if (spawn_engine_radical_origin == "chloroplast") {					maker = getRandomChloro();				}				if(maker != null){					for (var i:int = 0; i < spawn_engine_radical_count; i++) {						makeRadical(maker, false, spawn_engine_radical_target);					}				}			}		}				public function makeRadical(maker:CellObject,isInvincible:Boolean=false, targetStr:String=""):FreeRadical {			var r:FreeRadical = null;			if (isInvincible) {				r = new InvincibleRadical();			}else {				r = new NormalRadical();			}						r.x = maker.x + maker.getRadius() * (-0.5 + Math.random());			r.y = maker.y + maker.getRadius() * (-0.5 + Math.random());			r.setTargetStr(targetStr);			r.setMaker(maker);			addChild(r);			list_radical.push(r);			r.setCell(this);			addRunning(r);			addSelectable(r);			onMake("radical", list_radical.length);			r.init();			return r;		}				public function makeDNARepair():DNARepairEnzyme {			var d:DNARepairEnzyme = new DNARepairEnzyme();			addChild(d);			list_dnarepair.push(d);			d.setCell(this);			addRunning(d);			addSelectable(d);			onMake("dnarepair", list_dnarepair.length);			d.init();			return d;					}				public function makeEscortPoint(c:CellObject):HardPoint {			var h:HardPoint = new HardPoint();			//addChild(h);			list_hardpoint.push(h);			h.setCell(this);			addRunning(h);			h.setEscort(c);			h.init();						return h;		}				public function makeHardPoint():HardPoint {			var h:HardPoint = new HardPoint();			//addChild(h); //LATER WE WILL COMMENT THIS OUT			list_hardpoint.push(h);			h.setCell(this);			addRunning(h);			h.init();			return h;		}				public function makeSlicer(instant_deploy:Boolean=false):SlicerEnzyme {			var s:SlicerEnzyme = new SlicerEnzyme();			if(instant_deploy){				s.play_init_sound = false;				s.instant_deploy = true;			}			addChild(s);			list_slicer.push(s);			s.setCell(this);			addRunning(s);			addSelectable(s);			onMake("slicer", list_slicer.length);			s.init();			return s;		}				public function checkRNACount():int {			var count:int = 0;			for each(var r:RNA in list_rna){				if (r is MRNA || r is EnzymeRNA) {					count++;				}			}			return count;		}				public function checkEvilRNACount(wave:String):int {			var count:int = 0;			for each(var r:RNA in list_rna) {				if(wave != ""){					if (r.getProductCreator() == wave) {						count++;					}				}else {					if (r is EvilRNA || r is EvilDNA) {						count++;					}				}			}			//trace("Cell.checkEvilRNACount(" + wave + ") = " + count);			return count;		}				//Possible shlemiel! Watch out for huge virus lists!		public function checkVirusCount(wave:String):int {			var count:int = 0;			for each(var v:Virus in list_virus) {				if (v.wave_id == wave) {					count++;				}			}			//trace("Cell.checkVirusCount(" + wave + ") = " + count);			return count;		}				public function makeVirusWave(w:WaveEntry) {			var r:Number = CanvasObject.LENS_RADIUS;			//var vec:Vector2D = new Vector2D(0, CanvasObject.LENS_RADIUS * 1.1);						var RING_AMOUNT:int = 7;			var ring_list:Vector.<int> = new Vector.<int>();						var ring_count:int = 0;			var ring_max = RING_AMOUNT;			var count:int = 0;			var i:int = 0;			ring_list[0] = 0;						while (count < w.count) {				ring_list[ring_count]++;				if (ring_list[ring_count] >= ring_max) {					ring_list[ring_count + 1] = 0;					ring_count++;					ring_max *= 2;				}				count++;			}			count = 0;						//circlePoints			//var theVec:Vector2D			var listPoints:Vector.<Vector.<Number>> = new Vector.<Vector.<Number>>;			var mult:Number = 0.1;						for (i = 0; i < ring_list.length; i++) {				listPoints.push(circlePointsOffset(CanvasObject.LENS_RADIUS * (1.1 + mult), ring_list[count], cent_x, cent_y));				count++;				mult += 0.2;				//v = circlePointsOffset(radius:Number, MAX:Number, xo:Number, yo:Number			}						var listCirclePoints = new Vector.<Number>;			for each(var vvvv:Vector.<Number> in listPoints) {				//listCirclePoints.				for each(var n:Number in vvvv) {					listCirclePoints.push(n);				}				//listCirclePoints.push(vvvv.concat());// concat(vvvv);			}						var vesicle_count:int = w.count * w.vesicle;						var success_count:int = 0;			for (var i:int = 0; i < w.count; i++) {								var jiggX:Number = (Math.random() - 0.5) * 150;				var jiggY:Number = (Math.random() - 0.5) * 150;				var theX:Number = listCirclePoints[i*2] + jiggX;				var theY:Number = listCirclePoints[(i*2)+1] + jiggY;				var v:Virus = makeVirus(w.type, theX, theY);				if (v) {					success_count++;				}				v.wave_id = w.id;				if (i < vesicle_count) {					v.setVesicle(true);				}			}						updateViruses();			p_engine.makeVirus(w.type, w.id, success_count);		}				public function makeVirus(type:String, xx:Number,yy:Number,doEscape:Boolean=false,spendCost:Boolean=false):Virus {			var v:Virus;			var cost:Array;			if (type == "virus_injector") {				v = new VirusInjector();				//cost = Costs.MAKE_VIRUS_INJECTOR;				//cost[1] = VirusInjector.RNA_COUNT * Costs.MAKE_EVIL_RNA[1];			}			else if (type == "virus_invader") {				v = new VirusInvader(); 				//cost = Costs.MAKE_VIRUS_INVADER;				//cost[1] = VirusInvader.RNA_COUNT * Costs.MAKE_EVIL_RNA[1];			}			else if (type == "virus_infester") {				v = new VirusInfester();				//cost = Costs.MAKE_VIRUS_INFESTER;				//cost[1] = VirusInfester.RNA_COUNT * Costs.MAKE_EVIL_RNA[1];			}			//var proceed:Boolean = false;			var proceed:Boolean = true;			/*			if (spendCost) {		//if we are charging you for this virus - as in, did it spawn inside of you. Otherwise it's free				if (spend(cost)) {	//viruses steal your resources in order to be born					proceed = true;				}			}else {					//if we are not charging you for this virus - as in, it's spawning outside the cell. 				proceed = true;			}*/						if(proceed){ 				addChild(v);				v.setCanvas(p_canvas);				v.setCell(this);				list_virus.push(v);				addRunning(v);				onMake("type", list_virus.length); //this needs to change when we implement more than 1 virus type				v.x = xx;				v.y = yy;				v.setup(doEscape);			}else {				v.destruct();				v = null;			}			return v;		}				public function fireToxinParticle(xx:Number,yy:Number) {			var t:ToxinParticle = makeToxinParticle();			//makeToxin(xx, yy);			t.x = xx;			t.y = yy;			t.getOuttaHere();		}				public function makeToxinParticle():ToxinParticle {			var t:ToxinParticle = new ToxinParticle();			addChild(t);			t.setCell(this);			t.setCanvas(p_canvas);			list_junk.push(t);			addRunning(t);			var count:int = 0;			for each(var c:CellObject in list_junk) {				if (c is ToxinParticle) {					count++;				}			}			onMake("toxin_particle", count);			return t;		}				private function makeProteinGlob():ProteinGlob {			var p:ProteinGlob = new ProteinGlob();			addChild(p);			p.setCell(this);			list_junk.push(p);			addRunning(p);			var count:int = 0;			for each(var c:CellObject in list_junk) {				if (c is ProteinGlob) {					count++;				}			}			onMake("protein_glob", count);			return p;		}						private function makeMitochondrion():Mitochondrion {			var m:Mitochondrion = new Mitochondrion();			addChild(m);			m.setCell(this);			list_mito.push(m);			addSelectable(m);			addRunning(m);			onMake("mitochondrion",list_mito.length);			mitoCount = list_mito.length;			p_engine.setMitoCount(mitoCount);			return m;		}				private function makeTransportVesicle(product:int,amount:Number=1):TransportVesicle {			var t:TransportVesicle = new TransportVesicle();			t.setProduct(product,amount);			addChild(t);			t.setCell(this);			list_ves.push(t);			//addSelectable(t);			addRunning(t);			onMake("transport_vesicle", list_ves.length); //need to count actual transport vesicles			return t;		}				private function makePeroxisome():Peroxisome {			var p:Peroxisome = new Peroxisome();			addChild(p);			p.setCell(this);			list_perox.push(p);			addSelectable(p);			addRunning(p);			updateBasicUnits();			onMake("peroxisome", list_perox.length);			return p;		}				private function makeLysosome():Lysosome {			var l:Lysosome = new Lysosome();			addChild(l);			l.setCell(this);			list_lyso.push(l);			addSelectable(l);			addRunning(l);			updateBasicUnits();			onMake("lysosome",list_lyso.length);			return l;		}				/******/				private function updateViruses() {			c_membrane.updateViruses(list_virus);		}				private function updateBasicUnits() {			var list:Vector.<BasicUnit> = new Vector.<BasicUnit>;			for each(var s:SlicerEnzyme in list_slicer) {				list.push(s);			}for each(var p:Peroxisome in list_perox) {				list.push(p);			}for each(var l:Lysosome in list_lyso) {				list.push(l);			}for each(var r:Ribosome in list_ribo) {				list.push(r);			}for each(var d:DNARepairEnzyme in list_dnarepair) {				list.push(d);			}			/*list.splice(0, 0, Vector.<BasicUnit>(list_slicer.concat()));			list.splice(0, 0, Vector.<BasicUnit>(list_perox.concat()));			list.splice(0, 0, Vector.<BasicUnit>(list_lyso.concat()));			list.splice(0, 0, Vector.<BasicUnit>(list_ribo.concat()));*/			c_membrane.updateBasicUnits(list);		}				/******/				public function getGolgiLoc():Point {			var p:Point = new Point(c_golgi.x, c_golgi.y);			return p;		}								public function generateEvilRNA(i:int,count:int,wave_id:String="",startImmediately:Boolean=false,evilDNA:Boolean=false,doesVesicle:Boolean=false):EvilRNA {						var r:EvilRNA;			if(evilDNA == false){				r = new RedRNA(i, count, wave_id);			}else {				r = new EvilDNA(i, count, wave_id);			}						r.product_virus_vesicle = doesVesicle;						addChild(r);			list_rna.push(r);			r.setCell(this);			addRunning(r);			if(startImmediately){				r.doesRotateUp = true;				r.playAnim("fast_grow");			}else {				r.doesRotateUp = false;				r.playAnim("grow");			}			var wait:Boolean;			if(i != Selectable.VIRUS_INFESTER){				wait = !askForRibosome(r);				if (wait) {					r.waitForRibosome();				}			}else {				//trace("Cell.generateEvilRNA is INFESTER");				askForNucleusPore(r);				//wait = !askForNucleusPore(r);				//if (wait) {				//	r.waitForNucleusPore();				//}			}			return r;		}						public function onHealSomething(c:CellObject,n:Number) {			p_engine.notifyOHandler(EngineEvent.ENGINE_TRIGGER, "heal_thing", c.text_id, n);		}				public function getNucleusInfestation():int {			var max:int = c_nucleus.getMaxInfest();			var h:int = c_nucleus.getInfest();			var d:int = max - h;			return d;		}				public function getNucleusDamage():int {			var max:int = c_nucleus.getMaxHealth();			var h:int = c_nucleus.getHealth();			var d:int = max - h;			return d;		}				public function generateInfestRNA(i:int,creator:String):RNA {			var r:EvilRNA;			var virus_type:String = "";			switch(i) {				case Selectable.VIRUS_INFESTER:					r = new RedRNA(Selectable.VIRUS_INFESTER, VirusInfester.SPAWN_COUNT, creator); 					virus_type = "virus_infester";					break;			}			r.setNAValue(0);			addChild(r);			list_rna.push(r);			r.setCell(this);			addRunning(r);			//c_nucleus.getPore			var pt = c_nucleus.getPoreLoc(0,true);			r.x = pt.x;			r.y = pt.y;			r.playAnim("grow");			var wait:Boolean = !askForRibosome(r);			if (wait) {				r.waitForRibosome();			}			p_engine.onMakeEvilRNA(virus_type,creator,1);			return r;			//r = new EvilRNA(i,		}				public function generateMRNA(i:int,na:int):RNA {						var r:RNA;			if (i == Selectable.SLICER_ENZYME || i == Selectable.DNAREPAIR) {				r = new EnzymeRNA(i); //hack to get the animations right. We use an alternate RNA mc that has offset thread anims									 //you can use this for anything that generates proteins in place			}else{				r = new MRNA(i);	//the normal MRNA. use this for something that docks with a ribosome and uses the ER			}						r.setNAValue(na);									addChild(r);			list_rna.push(r);			r.setCell(this);			addRunning(r);			var pt:Point = c_nucleus.getPoreLoc(0,true);			r.x = pt.x;			r.y = pt.y;			r.playAnim("grow");			var wait:Boolean = !askForRibosome(r); //check for ribosomes			if (wait) {				r.waitForRibosome();			}			return r;		}		public function tauntByRadical(r:FreeRadical):Boolean {			//return peroxisomeEatSomething(r);			var p:Peroxisome = findClosestPeroxisome(r.x, r.y);			if (p) {				p.setTargetRadical(r);				return true;			}			return false;		}				public function tauntByVirus(v:Virus):Boolean {			/*var l:Lysosome = findClosestLysosome(v.x, v.y);			if (l) {				l.			}*/						return lysosomeEatSomething(v);		}				public function tauntByEvilRNA(e:EvilRNA):Boolean {			var s:SlicerEnzyme = findClosestSlicer(e.x, e.y);			if(s){				s.targetEvilRNA(e);				return true;			}			return false;		}				public function getRandomChloro():Chloroplast {			var length:int = list_chlor.length;			if(length > 0){				var m:int = Math.random() * length;				return list_chlor[m];			}			return null;		}				public function getRandomMito():Mitochondrion {			var length:int = list_mito.length;			if(length > 0){				var m:int = Math.random() * length;				return list_mito[m];			}			return null;		}				public function getRandomLyso():Lysosome {			var length:int = list_lyso.length;			if(length > 0){				var m:int = Math.random() * length;				return list_lyso[m];			}			return null;		}				public function getRandomSlicer():SlicerEnzyme {			var length:int = list_slicer.length;			if(length > 0){				var m:int = Math.random() * length;				return list_slicer[m];			}			return null;		}				public function getRandomPerox():Peroxisome{			var length:int = list_perox.length;			if(length > 0){				var m:int = Math.random() * length;				return list_perox[m];			}			return null;		}				private function findClosestSlicer(xx:Number, yy:Number):SlicerEnzyme {			var bestD2:Number = 10000000000000000;			var length:int = list_slicer.length;			var bestS:SlicerEnzyme = null;			for (var i:int = 0; i < length; i++) {				var s:SlicerEnzyme = list_slicer[i];				if(!s.hasRNA){ //if it doesn't already have a target					var dx:Number = xx - s.x;					var dy:Number = yy - s.y;					var d2:Number = (dx * dx) + (dy * dy);					if (d2 < bestD2) {						bestD2 = d2;						bestS = s;					}				}			}			//trace("Cell.findClosestSlicer(" + xx + "," + yy + ") = (" + bestS.x + "," + bestS.y + ")");			return bestS;		}				/*		public function freeGolgiExitPoint(i:int) {			c_golgi.freeExitPoint(i);		}		public function freeERExitPoint(i:int) {			c_er.freeExitPoint(i);		}				public function freeGolgiDockingPoint(i:int) {			c_golgi.freeDockingPoint(i);		}		public function freeERDockingPoint(i:int) {			c_er.freeDockingPoint(i);		}*/		public function dockGolgiVesicle(v:BlankVesicle):Boolean {//attempt to dock the vesicle to the Golgi						var pt:DockPoint = c_golgi.findDockingPoint();			if (pt) {				v.setDockPoint(pt,c_golgi.x,c_golgi.y);				//c_golgi.busyDockingPoint(pt.index);				return true;			}			return false;		}				public function dockRibosomeER(r:Ribosome):Boolean { //attempt to dock the ribosome to the Rough ER			//LYSO_RIB_FINISHED++;			//trace("Cell.dockRibosomeER() : LYSO_RIB_FINISHED= " + LYSO_RIB_FINISHED);				var pt:DockPoint = c_er.findDockingPoint();			if(pt){				r.setDockPoint(pt,c_er.x,c_er.y);				//c_er.busyDockingPoint(pt.index);				return true;			}			return false;		}				public function askForGolgiExit(v:BlankVesicle):Boolean {						var exit:DockPoint = c_golgi.findExitPoint();			if (exit != null) {				//trace("found exit " + exit.index);				//c_golgi.busyExitPoint(exit.index);				v.setExit(exit, c_golgi.x, c_golgi.y);				v.swimThroughGolgi();				return true;			}else {				v.waitForExit();			}			return false;		}				public function askForERExit(p:ProteinCloud):Boolean {			var exit:DockPoint = c_er.findExitPoint();			if(exit != null){				//c_er.busyExitPoint(exit.index);				p.setExit(exit,c_er.x,c_er.y);				p.swimER();			}else {				p.waitForExit();			}			return false;		}						public function getNucleusPore():Array {			return c_nucleus.getPorePoint();		}				public function askForNucleusPore(r:RNA):Boolean {			var a:Array = c_nucleus.getPorePoint();			if (a != null) {				r.setNPore(Point(a[0]), c_nucleus,int(a[1]));				return true;			}			return false;		}				/**		 * Given an MRNA, tries to assign it to the closest ribosome		 * @param	r the MRNA		 * @return boolean : whether the function succeeded		 */				public function askForRibosome(r:RNA):Boolean {			var ri:Ribosome = findClosestRibosome(r.x,r.y);			if (ri != null) {				r.setRibosome(ri);				return true;			}else if(list_ribo.length < 1){				p_engine.showAlert(Messages.A_NO_RIBO_RNA);			}			return false;		}				public function dismissLysosomes(b:BigVesicle) {			var length:int = list_lyso.length;			for (var i:int = 0; i < length; i++) {				if (list_lyso[i].fuse_target == b) {					list_lyso[i].dontFuseWithBigVesicle();				}			}		}				public function askForLysosomes(b:BigVesicle,howMany:int):int {			//trace("Cell.askForLysosomes(): " + howMany);			var gotMany:int = 0;			for (var i:int = 0; i < howMany; i++) {				var ly:Lysosome = findClosestLysosome(b.x, b.y);				if (ly != null) {								ly.fuseWithBigVesicle(b);					gotMany++;				}			}			if (gotMany < howMany) {				p_engine.showAlert(Messages.A_NO_LYSO_R);			}			return howMany - gotMany;			//return false;		}				public function findClosestPeroxisome(xx:Number, yy:Number):Peroxisome {			var dist2:Number = 1000000000;			var bestDist:Number = dist2;			var bestP:Peroxisome = null;						if (list_perox.length > 0) {				for each(var p:Peroxisome in list_perox) {					if (p.is_active && !p.isBusy) {						dist2 = getDist2(xx, yy, p.x, p.y);						if (dist2 < bestDist) {							bestP = p;							bestDist = dist2;						}					}				}			}			return bestP;		}				public function findClosestLysosome(xx:Number, yy:Number):Lysosome {			var dist2:Number = 1000000000;			var bestDist:Number = dist2;			var bestL:Lysosome = null;						var length:int = list_lyso.length;			if (length > 0){ //if there is at least one lysosome				for each(var ly:Lysosome in list_lyso) { //find the closest					if(!ly.amEating){						if (!ly.isRecycling && !ly.isBusy) {							dist2 = getDist2(xx, yy, ly.x, ly.y);							if (dist2 < bestDist) {								bestL = ly;								bestDist = dist2;							}						}					}				}			}			return bestL; //return the closest		}				public function findClosestRibosome(xx:Number,yy:Number,anyWillDo:Boolean=false):Ribosome {			var dist2:Number = 1000000000;			var bestDist:Number = dist2;			var bestR:Ribosome = null;						//OPTIMIZE SHLEMIEL			var length:int = list_ribo.length;			if (length > 0){ //if there is at least one ribosome				for each(var ri:Ribosome in list_ribo) { //find the closest					if (!ri.isBusy && ri.isReady() && !ri.isDoomed) {						dist2 = getDist2(xx, yy, ri.x, ri.y);						if (dist2 < bestDist) {							bestR = ri;							bestDist = dist2;						}					}/*else {						ri.checkFixBusy();					}*/				}			}									//if we couldn't find a free one, how bout we just give you anything, IF "anyWillDo" is true			if (bestR == null && anyWillDo) {				var i:int = Math.floor(Math.random() * (length - 1));				bestR = list_ribo[i];							}						return bestR; //return the closest		}				public function freePore(i:int=0):Boolean {			return c_nucleus.freePore(i);		}				public function sendERProtein(r:Ribosome, i:int) {			var p:ProteinCloud = new ProteinCloud();			p.x = r.x;			p.y = r.y;			p.setCell(this);			p.setProduct(i);			addChild(p);			addRunning(p);			setChildIndex(p, getChildIndex(c_er)+1); //put the protein cloud just "above" the ER;						askForERExit(p);		}				public function instantTransportVesicle(xx:Number, yy:Number, product:int, amount:Number=1,notifyEngine:Boolean = true):TransportVesicle {			var t:TransportVesicle = makeTransportVesicle(product,amount);			t.x = xx;			t.y = yy;			if (notifyEngine) {				//p_engine.finishTransportVesicle();			}			return t;		}				public function instantPeroxisome(xx:Number, yy:Number, notifyEngine:Boolean = true):Peroxisome {			var p:Peroxisome = makePeroxisome();			p.x = xx;			p.y = yy;						if (notifyEngine)				p_engine.finishPeroxisome();			return p;		}				public function instantLysosome(xx:Number, yy:Number,notifyEngine:Boolean=true):Lysosome {			var l:Lysosome = makeLysosome();			l.x = xx;			l.y = yy;			onFinishLysosome(l);			if(notifyEngine)				p_engine.finishLysosome();			return l;		}				public function budLysosome(xx:Number, yy:Number, r:Number):Lysosome {			var l:Lysosome = instantLysosome(xx, yy,false);			//p_engine.orderLysosome(); //keep the orders consistent			//p_engine.orderBasicUnit(			l.rotation = r;			l.bud();					return l;		}				public function growLysosome(xx:Number, yy:Number) {			//trace("GROW LYSOSOME");			var l:Lysosome = instantLysosome(xx, yy);			l.grow();		}				public function growPeroxisome(xx:Number,yy:Number) {			var p:Peroxisome = instantPeroxisome(xx, yy);			p.grow();		}				public function growToxinVesicle(xx:Number, yy:Number, amount:Number = 1) {			var t:TransportVesicle = instantTransportVesicle(xx, yy, Selectable.TOXIN, amount);			t.grow();		}				public function growDefensinVesicle(xx:Number, yy:Number, amount:Number=1) {			//var t:TransportVesicle = instant			var t:TransportVesicle = instantTransportVesicle(xx, yy, Selectable.DEFENSIN, amount);			t.grow();		}				public function growFinalVesicle(p:Point, i:int) {			//trace("GROW FINAL VESICLE! " + i);			//LYSO_VES_FINISHED++;			//trace("Cell.growFinalVesicle() : LYSO_VES_FINISHED= " + LYSO_VES_FINISHED);			switch(i) {				case Selectable.LYSOSOME: growLysosome(p.x, p.y); break;				case Selectable.PEROXISOME: growPeroxisome(p.x, p.y); break;				case Selectable.DEFENSIN: growDefensinVesicle(p.x, p.y, DEFENSIN_AMOUNT); break;				case Selectable.TOXIN: growToxinVesicle(p.x, p.y, TOXIN_AMOUNT); break;			}		}				public function growVesicle(p:ProteinCloud, i:int) {			//LYSO_VES_STARTED++;			//trace("Cell.growVesicle() : LYSO_VES_STARTED= " + LYSO_VES_STARTED);			var v:BlankVesicle;			switch(i) {				 				case Selectable.PEROXISOME: 					//growFinalVesicle(					growFinalVesicle(new Point(p.x, p.y), i);					break;				case Selectable.LYSOSOME:				case Selectable.TOXIN:				case Selectable.DEFENSIN: 					v = new PinkVesicle();					v.x = p.x;					v.y = p.y;					v.setCell(this);					v.setProduct(i);					addChild(v);					list_ves.push(v);					addRunning(v);					addSelectable(v);					//swapChildren(v, r); //put it behind the Ribosome					v.grow();					break;				case Selectable.MEMBRANE: 					growMembraneVesicle(p.x, p.y, 1);					break;			}		}				public function growMembraneVesicle(xx:Number, yy:Number, amount:Number = 1) {			var t:TransportVesicle = instantTransportVesicle(xx, yy, Selectable.MEMBRANE, 1);			t.growER();		}				public function generateVirusRNA(v:Virus,i:int,rnaCount:int,spawnCount:int,xx:Number,yy:Number,r:Number,startImmediately:Boolean=false,evilDNA:Boolean=false) {			for (var j:int = 0; j < rnaCount; j++){				var e:EvilRNA = generateEvilRNA(i,spawnCount,v.wave_id,startImmediately,evilDNA,v.doesVesicle);				e.x = xx;				e.y = yy;				if (v.mnode) {					e.setMnode(c_membrane.findClosestMembraneHalf(e.x, e.y)); //to be SURE					//e.setMnode(v.mnode);				}else {					//trace("Cell.generateVirusRNA() : no mnode!");				}				e.rotation = r;			}			if(!evilDNA){				p_engine.onMakeEvilRNA(v.text_id, v.wave_id, rnaCount);			}		}				public function onVirusInfest(s:String, i:int) {			p_engine.onVirusInfest(s, i);		}				public function onVirusEscape(s:String, i:int) {			p_engine.onVirusEscape(s, i);		}				public function onVirusSpawn(s:String, i:int) {			p_engine.onVirusSpawn(s, i);		}				public function getInfestWaveCount(s:String):int {			return p_engine.getInfestWaveCount(s);		}				public function getWave(s:String):WaveEntry{			return p_engine.getWave(s);		}				public function generateMembrane(na:int) {			generateMRNA(Selectable.MEMBRANE,na);		}				public function generateToxin(na:int) {			generateMRNA(Selectable.TOXIN, na);		}				public function generateDefensin(na:int) {			generateMRNA(Selectable.DEFENSIN,na);		}				public function generateLysosome(na:int):Boolean {			return generateMRNA(Selectable.LYSOSOME,na) != null;		}				public function generatePeroxisome(na:int):Boolean {			return generateMRNA(Selectable.PEROXISOME,na) != null;		}				public function generateDNARepair(na:int):Boolean {			return generateMRNA(Selectable.DNAREPAIR,na) != null;		}				public function generateSlicer(na:int):Boolean {			return generateMRNA(Selectable.SLICER_ENZYME,na) != null;		}		/**		 * Starts the process of producing a ribosome		 */				public function generateRibosome():Boolean {			var r:Ribosome = makeRibosome(); //make the ribosome;			var p:Point = c_nucleus.getPoreLoc(1); //get a nucleolus pore			/*r.x = p.x + (Math.random()*30 - 15);			r.y = p.y + (Math.random()*40 - 20);*/			r.x = p.x;			r.y = p.y-10;			r.playAnim("grow");			//p_engine.plusRibosome()			p_engine.finishRibosome();			if (r) { return true };			return false;		}				/**		 * Creates a Ribosome object		 * @return a Ribosome object		 */		private function makeRibosome(instant_deploy:Boolean=false):Ribosome {			var r:Ribosome = new Ribosome();			r.instant_deploy = instant_deploy;			addChild(r);			r.setCell(this);			list_ribo.push(r);			addSelectable(r);			addRunning(r);			updateBasicUnits();			onMake("ribosome",list_ribo.length);			return r;		}								public function getPpodContract(xx:Number, yy:Number) {			var centnum:int = Selectable.CENTROSOME;			for each(var c:CellObject in list_running) {				if (c.num_id != centnum) {					if(c != c_membrane && c != c_skeleton){						c.getPpodContract(xx, yy);					}				}			}			onCellMove(xx, yy);		}				public function moveCellTo(xx:Number, yy:Number) {			var dx:Number = xx - c_centrosome.x;			var dy:Number = yy - c_centrosome.y;			moveCell(dx, dy);		}				public function moveCell(xx:Number, yy:Number) {			//trace("Cell.moveCell(" + xx + "," + yy + ")");			for each(var c:CellObject in list_running) {				c.doCellMove(xx, yy);			}			onCellMove(xx, yy);		}				public function clearMouse() {			if (c_membrane) {				c_membrane.clearMouse();			}		}				private function onCellMove(xx:Number, yy:Number) {			c_membrane.onCellMove(xx, yy);			p_world.onCellMove(c_centrosome.x,c_centrosome.y);			p_canvas.onCellMove(xx,yy);			updateObjectGridLoc();			GameObject.setCentLoc(c_centrosome.x, c_centrosome.y);			if(p_woz){				p_woz.tickSpace();			}			/*if(p_woz)				p_woz.tick(null);*/		}				/*****Organelle killing functions*****/				public function killProteinCloud(p:ProteinCloud) {			var i:int = 0;			for each(var g:GameObject in list_running) {				if (p == g) {					list_running.splice(i, 1);				}				i++;			}			removeChild(p);			p.destruct();			p = null;		}				public function killBlankVesicle(b:BlankVesicle) {			var i:int = 0;			for each(var ves:BlankVesicle in list_ves) {				if (ves == b) {					list_ves.splice(i, 1);				}				i++;			}			killRunning(GameObject(b));			killSelectable(Selectable(b));		}		public function sellSomething(i:int):Boolean {			switch(i) {				case Selectable.LYSOSOME: 					return startRecycleLysosome();					break;				case Selectable.RIBOSOME: 					return startRecycleRibosome();					break;				case Selectable.SLICER_ENZYME: 					break;				case Selectable.PEROXISOME: 					break;			}			return false;		}				public function startRecycleRibosome():Boolean {			var length:int = list_ribo.length;			if (length > 0) {				var j:int = length - 1;				while (j >= 0) {					if (!list_ribo[j].isBusy && !list_ribo[j].isRecycling) {						return startRecycle(list_ribo[j]);					}					j--;				}			}			return false;		}				public function startRecycleLysosome():Boolean {			var length:int = list_lyso.length;			if (length > 0) {				var j:int = length-1;				while (j >= 0) {					if(!list_lyso[j].isRecycling && list_lyso[j].is_active && !list_lyso[j].isBusy){						return startRecycle(list_lyso[j]);					}					j--;				}			}						return false;		}				public function neutralizeViruses() {			for each(var v:Virus in list_virus) {				v.neutralize();			}			p_woz.neutralizeViruses();		}				public function onMembraneHealthChange(i:int) {			p_interface.setMembraneHealth(i);		}				public function startNecrosis():Boolean {						if (Director.STATS_ON) { Log.LevelCounterMetric("cell_start_necrosis", Director.level); }			if(Director.STATS_ON){Log.LevelAverageMetric("cell_start_necrosis", Director.level,1);}						neutralizeViruses();			//var list_tubes:Vector.<Microtubule> = c_skeleton.getTubes();			isCellDying = true;			var popArray:Array = c_membrane.getPopPoints();			var i:int = 0;			if(popArray[0]){				for each(var p:Point in popArray[0]) {					//trace("Cell.startNecrosis p = " + p);					if (popArray[1]) {						makeSplashBurst(popArray[1][i], p.x, p.y, 1);						//makePopVesicle(popArray[1][i], popArray[0].x, popArray[0].y, 1);						i++;					}				}			}						c_membrane.visible = false; //hide the membrane;			addEventListener(RunFrameEvent.RUNFRAME, doNecrosis);			//loseResources([r_atp, r_na, r_aa, r_fa, r_g]);			zeroResources();			return true;		}				public function nucleusCallForHelp() {			for each(var d:DNARepairEnzyme in list_dnarepair) {				if (d.goingNucleus == false) {					d.tryGoNucleus();				}			}		}				private function doNecrosis(r:RunFrameEvent) {						if (necrosisCount < NECROSIS_TIME + 1) {				//guaranteed to kill everything!				var t:Number = NECROSIS_TIME / 4;				//loseResources([r_max_atp / t, r_max_na / t, r_max_aa / t, r_max_fa / t, r_max_g / t]);				for each(var s:CellObject in list_running) {	//kill all my stuff					if (s.dying == false && !(s is Virus)) { //don't kill anything that'd already dead, or a virus						var health:Number = s.getMaxHealth();						if (health <= 100) {							s.takeDamage(health / (NECROSIS_TIME / 4)); //wipe out low health fast						}						if (health <= 300) {													s.takeDamage(health/(NECROSIS_TIME/2)); //medium health semi fast						}else{							s.takeDamage(health/NECROSIS_TIME); //everything else slower						}					}				}			}						necrosisCount++;									if (necrosisCount >= NECROSIS_TIME * 0.75) { 				necrosisCount = 0;				removeEventListener(RunFrameEvent.RUNFRAME, doNecrosis);				endNecrosis();			}		}				private function endNecrosis() {			if(Director.STATS_ON){Log.LevelAverageMetric("cell_finish_necrosis", Director.level, 1);}			if(Director.STATS_ON){Log.LevelCounterMetric("cell_finish_necrosis", Director.level);}			zeroResources();			//loseResources([r_atp, r_na, r_aa, r_fa, r_g]); //in case we got some back from recycling			//trace("Cell.endNecrosis!");			//trace("Cell.endNecrosis list_mito = " + list_mito);			//trace("Cell.endNecrosis list_selectable = " + list_selectable);			//trace("Cell.endNecrosis list_running = " + list_running);			p_engine.onNecrosis("lysis");		}		public function getEngineSelectCode():int {			return p_engine.getSelectCode();		}				public function engineUpdateSelected() {			p_engine.updateSelected();		}		public function showToxinSpot(amt:Number, x:Number, y:Number) {			p_engine.showToxinSpot(amt, x, y);		}				public function showShieldBlock(x:Number, y:Number) {			Director.startSFX(SoundLibrary.SFX_BLOCK);			p_engine.showShieldBlock(x, y);		}				public function showShieldSpot(amt:Number, x:Number, y:Number) {			p_engine.showShieldSpot(amt, x, y);		}				public function showHealSpot(amt:Number, x:Number, y:Number) {			p_engine.showHealSpot(amt, x, y);		}				public function canAfford(atp:Number, na:Number, aa:Number, fa:Number, g:Number):Boolean {			return p_engine.canAfford(atp, na, aa, fa, g);		}				public function cancelRecycle(c:CellObject) {			if (c.isInVesicle == true) {				c.myVesicle.cancelRecycle();			}		}				public function startRecycle(s:Selectable,many:Boolean=false):Boolean {			//trace("Cell.startRecycle( " + s + "="+s.text_id +")");			switch(s.num_id) {				case Selectable.RIBOSOME:				case Selectable.LYSOSOME:				case Selectable.MITOCHONDRION:				case Selectable.PROTEIN_GLOB:				case Selectable.SLICER_ENZYME:				case Selectable.CHLOROPLAST:				case Selectable.PEROXISOME:				case Selectable.DNAREPAIR:				var a:Array = Costs.getRecycleCostByName(s);				if(spendATP(a[0])){					return s.tryRecycle(many);				}else {					p_engine.showImmediateAlert(Messages.A_NO_AFFORD_RECYCLE);					return false;				}				break;								default:					return lysosomeEatSomething(s);					break;			}									//return success;		}				public function abortProduct(i:int) {			p_engine.abortProduct(i);		}				public function makeStarburst(xx:Number, yy:Number) {			var s:StarBurst = new StarBurst();			s.x = xx;			s.y = yy;			s.p_cell = this;			addChild(s);			s.gotoAndPlay("burst");			//trace("Cell.makeStarburst(" + xx + "," + yy + ")");			Director.startSFX(SoundLibrary.SFX_HURT);		}				public function removeStarburst(s:StarBurst) {			removeChild(s);		}				/**		 * When you finish a lysosome, it looks to see if there is acid in the cytosol. If so, it sucks it out		 * @param	l		 */						 		public function onFinishLysosome(l:Lysosome) {			if (ph_balance < 7.5) {								var new_ph:Number = PH.removeFromPH(Lysosome.PH_BALANCE, l.getCircleVolumeX(),												ph_balance, c_membrane.getCircleVolume());				if (new_ph > 7.5) {					new_ph = 7.5;				}				setPH(new_ph);			}		}				public function onPopLysosome(l:Lysosome) {			onRecycle(l,true,true);			onRecycle(l,true,true);			var new_ph:Number = PH.mergePH(Lysosome.PH_BALANCE, l.getCircleVolumeX(), 										   ph_balance, c_membrane.getCircleVolume());			setPH(new_ph);			//mergePH(Lysosome.ph_balance,l.getCircleVolume());			//addAcid(l.acid_amount,l.getCircleVolume());		}				private function setPH(ph:Number) {			ph_balance = ph;			p_interface.setPH(ph);			c_membrane.updatePH(ph_balance);			onPHChange();		}						private function onUnitChange() {			var lm:Number = list_mito.length;			var lc:Number = list_chlor.length;			var ls:Number = list_slicer.length;			var lp:Number = list_perox.length;			var ll:Number = list_lyso.length;						FreeRadical.updateChances(lm, lc, ls, lp, ll);		}				private function onPHChange() {			for each(var c:CellObject in list_running) {				if(!c.isInVesicle){					c.setPHDamage(ph_balance);				}			}		}		public function onMembraneUpdate(hardUpdate:Boolean=false) {			var size:Number = c_membrane.getRadius() * 3;			var gridSize:Number = size*2; //twice as big as the radius = box			p_world.updateMaskSize(size);			updateObjectGrid(gridSize, gridSize,hardUpdate);			updateObjectGridLoc();		}				public function updateObjectGridLoc() {			c_objectGrid.x = cent_x - c_objectGrid.getSpanW() / 2;			c_objectGrid.y = cent_y - c_objectGrid.getSpanH() / 2;			p_canvas.updateCanvasGridLoc(c_objectGrid.x, c_objectGrid.y);		}				private function updateObjectGrid(w:Number, h:Number, hardUpdate:Boolean = false) {			c_objectGrid.wipeGrid();			c_objectGrid.makeGrid(GRID_W,GRID_H, w, h);			c_objectGrid.displayGrid();						//update everything that needs to know the differences			GameObject.setGrid(c_objectGrid);			c_membrane.setObjectGrid(c_objectGrid);			p_canvas.updateCanvasGrid(GRID_W, GRID_H, w, h,hardUpdate);		}				public function showGrid() {			c_objectGrid.displayGrid();			addChild(c_objectGrid);			p_canvas.showGrid();		}				public function hideGrid() {			if(getChildByName(c_objectGrid.name))				removeChild(c_objectGrid);			p_canvas.hideGrid();		}				/*private function addAcid(a:Number,lvol:Number) {			var vol:Number = c_membrane.getVolume();			var phvol:Number = ph_balance * vol;			var acid:Number = a * lvol;			trace("Cell.addAcid() ph was = " + ph_balance);			trace("Cell.addAcid() a = " + a + " lvol = " + lvol + " vol = " + vol);			ph_balance = (phvol - acid) / (vol+lvol);			trace("Cell.addACid() ph_balance = " + ph_balance);			p_interface.setPH(ph_balance);		}*/				/**		 * When something is recycled, you call this function.		 * @param	s			The thing to recycle		 * @param	reimburse	Do we get its resources? Yes, by default		 */				public function onRecycle(s:Selectable, reimburse:Boolean = true, announce:Boolean = false) {			//trace("Cell.onRecycle() " + s.text_id + " reimburse="+reimburse);			if (reimburse && !isCellDying) {				if (announce) {					if (s.recycleOfMany) {						p_engine.recycleSomethingOfMany(s.num_id, new Point(s.x, s.y));					}else{						p_engine.recycleSomething(s.num_id, new Point(s.x, s.y));					}				}else{					p_engine.recycleSomething(s.num_id);				}			}			killSomething(s);		}			public function bigVesicleRecycleSomething(c:CellObject):Boolean {			var v:BigVesicle= growBigVesicleFor(c);			if (v) {				c.makeDoomed();				return true;			}			return false;		}				public function lysosomeEatSomething(s:Selectable):Boolean {						var l:Lysosome = findClosestLysosome(s.x, s.y);			if (l) {				return l.eatSomething(s);			}						//if we got here, we failed						if (list_lyso.length < 1) { //if we have no lysosomes				if(!(s is Virus)){			//don't show this alert if it's a virus we're eating					p_engine.showAlert(Messages.A_NO_LYSO_R); //Alert that we need lysosomes for recyclnig				}			}						return false;		}				public function killSomething(s:Selectable) {			switch(s.num_id) {				case Selectable.NUCLEUS:					killNucleus(Nucleus(s));					break;				case Selectable._ER:					killER(ER(s));					break;				case Selectable.CENTROSOME:					killCentrosome(Centrosome(s));					break;				case Selectable.GOLGI:					killGolgi(Golgi(s));					break;				case Selectable.LYSOSOME: 					killLysosome(Lysosome(s));					break;				case Selectable.PEROXISOME:					killPeroxisome(Peroxisome(s));					break;				case Selectable.RIBOSOME:					killRibosome(Ribosome(s));					break;				case Selectable.VESICLE:					killBlankVesicle(BlankVesicle(s));					break;				case Selectable.CHLOROPLAST:					killChloroplast(Chloroplast(s));					break;				case Selectable.MITOCHONDRION:					killMitochondrion(Mitochondrion(s));					break;				case Selectable.BIGVESICLE:					killBigVesicle(BigVesicle(s));					break;				case Selectable.PROTEIN_GLOB:					killProteinGlob(ProteinGlob(s));					break;				case Selectable.SLICER_ENZYME:					//trace("Cell.killSomething() slicerEnzyme(" + s + ")");					killSlicerEnzyme(SlicerEnzyme(s));					break;				case Selectable.DNAREPAIR:					killDNARepair(DNARepairEnzyme(s));					break;				case Selectable.FREE_RADICAL:					killFreeRadical(FreeRadical(s));					break;				case Selectable.VIRUS:				case Selectable.VIRUS_INFESTER:				case Selectable.VIRUS_INJECTOR:				case Selectable.VIRUS_INVADER:					killVirus(Virus(s));					break;				default:					throw new Error("Cell.killSomething() : I don't recognize code # " + s.num_id);					break;			}		}				public function killRunning(g:GameObject) {			var i:int = 0;			for each(var gg:GameObject in list_running) {				if (g == gg) {					list_running.splice(i, 1);				}				i++;			}			if (g is HardPoint) {							}else{				removeChild(g);			}			g.destruct();			g = null;		}				public function killSelectable(s:Selectable) {			var i:int = 0;			for each(var ss:Selectable in list_selectable) {				if (s == ss) {					list_selectable.splice(i, 1);				}				i++;			}			dirty_selectList = true;		}				public function killPeroxisome(p:Peroxisome) {			var i:int = 0;			for each(var pp:Peroxisome in list_perox) {				if (pp == p) {					list_perox.splice(i, 1);				}				i++;			}			if (p.orderOnDeath) {								p_engine.replacePerox();// (BasicUnit.PEROXISOME, 1);			}			p_engine.oneLessPeroxisome();			onKill(p.text_id, list_perox.length);			killSelectable(Selectable(p));			killRunning(GameObject(p));		}				public function killVirus(v:Virus) {			var i:int = 0;			for each(var vv:Virus in list_virus) {				if (vv == v) {					list_virus.splice(i, 1);				}				i++;			}						killRunning(GameObject(v));						//p_engine.onKillVirus(			p_engine.onKillVirus(v.wave_id);// , v.type);		}		public function onAbsorbRadical(p:Peroxisome) {			setChildIndex(p, numChildren - 1); //so it doesn't get buried under organelles			p_engine.notifyOHandler(EngineEvent.ENGINE_TRIGGER, "absorb_radical", "null", 1);		}				public function killFreeRadical(f:FreeRadical) {			var i:int = 0;			for each(var ff:FreeRadical in list_radical) {				if (ff == f) {					list_radical.splice(i, 1);				}				i++;			}			onKill(f.text_id, list_radical.length);			killSelectable(Selectable(f));			killRunning(GameObject(f));			}				public function killDNARepair(d:DNARepairEnzyme) {			var i:int = 0;			for each(var dd:DNARepairEnzyme in list_dnarepair) {				if (dd == d) {					list_dnarepair.splice(i, 1);				}				i++;			}			onKill(d.text_id, list_dnarepair.length);			p_engine.oneLessDNARepair();			killSelectable(Selectable(d));			killRunning(GameObject(d));		}				public function killHardPoint(h:HardPoint) {			var i:int = 0;			//removeChild(h);			for each(var hh:HardPoint in list_hardpoint) {				if (hh == h) {					list_hardpoint.splice(i, 1);				}				i++;			}			killSelectable(Selectable(h));			killRunning(GameObject(h));		}				public function killSlicerEnzyme(s:SlicerEnzyme) {			//trace("Cell.killSlicerEnzyme() " + s );			var i:int = 0;			for each(var ss:SlicerEnzyme in list_slicer) {				if (ss == s) {					list_slicer.splice(i, 1);				}				i++;			}			onKill(s.text_id, list_slicer.length);			p_engine.oneLessSlicer();			killSelectable(Selectable(s));			killRunning(GameObject(s));					}				public function killProteinGlob(g:ProteinGlob) {			var i:int = 0;			for each(var pg:ProteinGlob in list_junk) {				if (pg == g) {					list_junk.splice(i, 1);				}				i++;			}						killRunning(GameObject(g));			killSelectable(Selectable(g));		}				public function unDoomCheck(c:CellObject) {			p_engine.unDoomCheck(c);		}				public function killBigVesicle(b:BigVesicle) {						var i:int = 0;			for each(var bi:BigVesicle in list_bigves) {				if (b == bi) {					list_bigves.splice(i, 1);				}				i++;			}			onKill(b.text_id, list_bigves.length);			killRunning(GameObject(b));			killSelectable(Selectable(b));		}								public function killNucleus(n:Nucleus) {			killRunning(GameObject(n));			killSelectable(Selectable(n));			onKill(n.text_id, 0);			c_nucleus = null;			checkNucleusScrewed();			//p_engine.onNecrosis("no_nucleus");			//trace("Cell.killNucleus() GAME OVER!");		}				public function killER(er:ER) {			killRunning(GameObject(er));			killSelectable(Selectable(er));			onKill(er.text_id, 0);			c_er = null;			//trace("Cell.killER() GAME OVER!");		}				public function killGolgi(g:Golgi) {			killRunning(GameObject(g));			killSelectable(Selectable(g));			onKill(g.text_id, 0);			c_golgi = null;			//trace("Cell.killGolgi()!");		}				public function killCentrosome(cent:Centrosome) {			/*killRunning(GameObject(cent));			killSelectable(Selectable(cent));			c_centrosome = null;*/			//trace("Cell.killCentrosome() GAME OVER!");		}				public function checkScrewed(c:CellObject) {			switch(c.num_id) {				case Selectable.MITOCHONDRION: checkMitoScrewed();  break;				case Selectable.CHLOROPLAST: checkChloroScrewed();  break;				case Selectable.NUCLEUS: checkNucleusScrewed(); break;			}		}				public function checkNucleusScrewed() { //ONLY called by the nucleus when health is <= 0!			if(!isCellDying){ //so it doesn't double fire on lysis				p_engine.showScrewedMenu("gameover", "no_nucleus");			}		}				private function checkMitoScrewed() {			if(!isCellDying){				var count:int = 0;				for each(var mi:Mitochondrion in list_mito) {					if (mi.getDamageLevel() < 2) {						count++;					}				}				if (count <= 0) {					p_engine.showScrewedMenu("screwed",MenuSystem_Screwed.NO_MITO);				}			}		}				private function checkChloroScrewed() {			if(!isCellDying){				var count:int = 0;				if(lvl_sunlight > 0){ //if there's no sunlight, who cares?					for each(var ch:Chloroplast in list_chlor) {						if (ch.getDamageLevel() < 2) {							count++;						}					}					if (count <= 0) {						p_engine.showScrewedMenu("screwed",MenuSystem_Screwed.NO_CHLORO);					}				}			}		}				public function killMitochondrion(m:Mitochondrion) {			var i:int = 0;			for each(var mi:Mitochondrion in list_mito) {				if (m == mi) {					list_mito.splice(i, 1);				}				i++;			}						onKill(m.text_id, list_mito.length);			killRunning(GameObject(m));			killSelectable(Selectable(m));			mitoCount = list_mito.length;			p_engine.setMitoCount(mitoCount);			checkMitoScrewed();		}				public function killToxinParticle(t:ToxinParticle) {			var i:int = 0;			var t_count:int = 0;			for each(var c:CellObject in list_junk) {				if (c is ToxinParticle) {					t_count++;				}				if (t == c) {					list_junk.splice(i, 1);				}				i++;			}			onKill(t.text_id, t_count);			killRunning(GameObject(t));			killSelectable(Selectable(t));		}				public function killChloroplast(c:Chloroplast) {			var i:int = 0;			for each(var ch:Chloroplast in list_chlor) {				if (c == ch) {					list_chlor.splice(i, 1);				}				i++;			}			onKill(c.text_id, list_chlor.length);			killRunning(GameObject(c));			killSelectable(Selectable(c));			chloroCount = list_chlor.length;			p_engine.setChloroCount(chloroCount);			checkChloroScrewed();		}				public function killRibosome(r:Ribosome) {			var i:int = 0;			for each(var ri:Ribosome in list_ribo) {				if (r == ri) {					list_ribo.splice(i, 1);				}				i++;			}			onKill(r.text_id, list_ribo.length);			p_engine.oneLessRibosome();			killRunning(GameObject(r));			killSelectable(Selectable(r));		}						public function killSplashBurst(s:SplashBurst) {						killRunning(GameObject(s));					}				public function killLysosome(l:Lysosome) {			var i:int = 0;			for each(var ly:Lysosome in list_lyso) {				if (l == ly) {					list_lyso.splice(i, 1);				}				i++;			}			onKill(l.text_id, list_lyso.length);						if(!l.fusing){ //if the Lysosome is just going to merge with a vesicle, don't tell the engine				p_engine.oneLessLysosome();			}						killRunning(GameObject(l));			killSelectable(Selectable(l));		}				public function killRNA(r:RNA) { //This function could use some optimization			var i:int = 0;			if(r is EvilRNA){				p_engine.recycleRNA(0);			}else {				p_engine.recycleRNA(r.getNAValue());			}			for each(var rna:RNA in list_rna) {				if (rna == r) {					list_rna.splice(i, 1);				}				i++;			}			i = 0;			for each(var g:GameObject in list_running) {				if (r == g) {					list_running.splice(i, 1);				}				i++;			}			/*if (i == Selectable.LYSOSOME) {				//LYSO_RNA_FINISHED++;				//trace("Cell.killRNA() : LYSO_RNA_FINISHED = " + LYSO_RNA_FINISHED);			}*/						if (r is EvilRNA && !(r is EvilDNA)) {				p_engine.onKillEvilRNA(r.getProductCreator());// , r.getProduct());			}			onKill(r.text_id, list_rna.length);						removeChild(r);			r.destruct();			r = null;		}				public function onNucleusInfest(b:Boolean) {			p_engine.onNucleusInfest(b);		}				public function checkMembraneStrength(c:CellObject):Number{			var list:Vector.<MembraneNode> = c_membrane.getClosestNodes(c.x, c.y, gravRadius2);			//trace("CHeck membrane strength");			var worstStretch:Number = 10;			for each(var m:MembraneNode in list) {				//trace("Stretch = " + m.stretch);				if (m.stretch < worstStretch) {					worstStretch = m.stretch;				}			}			//trace("worstStretch = " + worstStretch);			return worstStretch;		}				public function updateOrganelleAct(s:String, v:Vector.<int>) {			//var l:Vector.<CellObject>;			if (s == "nucleus") c_nucleus.setActions(v);			else if (s == "centrosome") c_centrosome.setActions(v);			else if (s == "er") c_er.setActions(v);			else if (s == "golgi") c_golgi.setActions(v);			else if (s == "mitochondrion") {				for each(var m:Mitochondrion in list_mito) {					m.setActions(v);				}			}else if (s == "chloroplast") {				for each(var c:Chloroplast in list_chlor) {					c.setActions(v);				}			}else if (s == "slicer") {				for each(var se:SlicerEnzyme in list_slicer) {					se.setActions(v);				}			}else if (s == "ribosome") {				for each(var r:Ribosome in list_ribo) {					r.setActions(v);				}			}else if (s == "peroxisome") {				for each(var p:Peroxisome in list_perox) {					p.setActions(v);				}			}else if (s == "lysosome") {				for each(var l:Lysosome in list_lyso) {					l.setActions(v);				}			}		}				public function getActionListFromEngine(i:int):Vector.<int> {			var v:Vector.<int> = p_engine.lookupActionList(i);			if(v){				return v; //return a copy			}			return null;		}				/**		 * Gets the cost to ppod to that location		 * @param	xx yy		 * @return cost of movement		 */				public function getPPodCost(xx:Number, yy:Number):Number {						var p:Point = new Point(xx,yy);			p = p_world.transformPoint(p);			//var dist:Number = getDist(p.x, p.y, p_selected.x, p_selected.y);			var dx:Number = p.x - cent_x;			var dy:Number = p.y - cent_y;			var d2:Number = (dx * dx) + (dy * dy);			d2 /= Costs.MOVE_DISTANCE2;			var cost:Number = (Costs.PSEUDOPOD[0] * d2);			return cost;		}	}	}