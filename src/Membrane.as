package  {	import com.cheezeworld.math.Vector2D;	import com.pecLevel.EngineEvent;	import flash.display.Shape;	import flash.display.Sprite;	import flash.geom.Point;	import fl.motion.Color;	import flash.display.CapsStyle;	import flash.display.JointStyle;	import flash.events.MouseEvent;	import flash.events.Event;	/**	 * ...	 * @author Lars A. Doucet	 */	public class Membrane extends CellObject	{		private var list_nodes:Vector.<MembraneNode>;		private var list_grav:Vector.<GravPoint>;		private var list_basicUnits:Vector.<BasicUnit>;		private var list_viruses:Vector.<Virus>;		private var list_grav_blank:Vector.<GravPoint>;		//private var list_shields:Vector.<ShieldIcon>;				private var p_cent:Centrosome;		private var p_skeleton:Cytoskeleton;		public var skeletonReady:Boolean = false;				private var membraneSprite:Sprite;		private var iconSprite:Sprite;				public var shape_spring:Shape;		//public var shape_node:Shape;		public var shape_gap:Shape;		public var shape_cyto:Shape;		public var shape_outline:Shape;				public var targetter:Targetter;				public var shape_debug:Shape;				public static var cyto_volume:Number = 0;				public static var MIN_STRETCH:Number = 0.35;		public static var MAX_STRETCH:Number = 1 - MIN_STRETCH;		public static var ACC_STRETCH:Number = MAX_STRETCH*0.5;		public static var MIN_COLOR_STRETCH:Number = MIN_STRETCH*2;		public static var AVG_STRETCH:Number = 1;				public static const MAX_DEFENSIN_STRENGTH:Number = 0.5;				private const DEBUG:Boolean = true;		public static var SHOW_GRAVPOINTS:Boolean = false;		public static var SHOW_NODES:Boolean = false;				public static const DRAW_CURVES:Number = 0;		public static const DRAW_LINES:Number = 1;				public static var DRAW_QUALITY:Number = DRAW_CURVES; //draw curves				private const SHOWLINES:Boolean = true;				public static const SPRING_THICK_:Number = 35;		public static const GAP_THICK_:Number = 15;		public static const OUTLINE_THICK_:Number = 40;				public static var SPRING_THICK:Number = SPRING_THICK_;		public static var GAP_THICK:Number = GAP_THICK_;		public static var OUTLINE_THICK:Number = OUTLINE_THICK_;				private static const SPRING_MIN:Number = 13;		private static const GAP_MIN:Number = 4;		private static const OUTLINE_MIN:Number = 15;				private static const HEALTH_PER_NODE:Number = 10;		private var HEALTH_COUNT:int = 60; //+1 health every 2 seconds		private var healthCounter:int = HEALTH_COUNT;				private var D_NODECLICK:Number = 50;		private var D2_NODECLICK:Number = D_NODECLICK*D_NODECLICK;		private var D_MNODECLICK:Number = 50 * .75;		private var D2_MNODECLICK:Number = D_MNODECLICK * D_MNODECLICK;				private var D_BASIC_UNIT_COLLIDE:Number = 70;		private var D2_BASIC_UNIT_COLLIDE:Number = D_BASIC_UNIT_COLLIDE*D_BASIC_UNIT_COLLIDE;		private const OBJ_FUDGE:Number = 1; //the "effective" size of an object gravpoint radius for a hard collision		private var waitRecycleCounter:int = 0;		private var waitForRecycle:Boolean = false;				private var waitCounter:int = 0;				private var isDragging:Boolean = false; 		private var isPPodCursor:Boolean = false;		private var isMouseOver:Boolean = false; 		private var isMouseDown:Boolean = false; //did we click the mouse down on this object		private var mouseDown_x:Number = 0;		private var mouseDown_y:Number = 0;				private var isPPoding:Boolean = false;				private var d2_mouse:Number = 0;		private static const D2_PPOD:Number = 100 * 100; //100 pixels		public static const PPOD_ANGLE:Number = 90; //+- 30 degrees				private var worldScale:Number = 1;				//private var p_engine:Engine;		private var p_objectGrid:ObjectGrid;				private var dummy_flag:Boolean = false;		private var endDummy:Boolean = false;				private var dummy_lastPoint:Point;		private var dummy_nextPoint:Point;				private var dummy_avgPoint:Point;		private var dummy_midPoint:Point;		private var dummy_midPoint2:Point;		private var dummyCounter:int = 0;				/*private var ph_balance:Number = 7.5;	  //the real number		private var ph_balance_show:Number = 7.5; //the number we show - add a delay for animation*/				private var cyto_col:uint = 0x44AAFF;		private var spring_col:uint = 0x0066FF;		private var gap_col:uint = 0x99CCFF;				private var health_col:uint;		private var health_col2:uint;				public static const STARTING_RADIUS:Number = 400;		public static const STARTING_NODES:int = 15;		public static const MAX_NODES:int = 25;				public static var CURR_NODES:int = 15;				private var p_cgrid:ObjectGrid;		//private var p_virusGrid:ObjectGrid;				private const D2_NODERADIUS:Number = 10;				private var defensins:Number=0; 				//how many defensins do we have?		public static var defensin_strength:Number=0; //chance of killing incoming viruses		private const MAX_DEFENSIN_PER_NODE:Number = 1; //you need X defensins per node for maximum strength		//private var shieldsOn:Boolean = false;				private var penetrate_unit_vector:Vector2D;		private var penetrate_vector:Vector2D; //used for pushing goodiegems away				//private var NODES_PER_SHIELD:int = 5;		//private var shieldCounter:int = NODES_PER_SHIELD;				private var wait_cent_count:int = 0;		private const WAIT_CENT_TIME:int = 30;		private const WAIT_CENT_TIME_SHORT:int = 5;				public var acceptingVesicles:Boolean = true;				public function Membrane() 		{			defensin_strength = 0;			canSelect = false;			//singleSelect = true;			text_title = "Membrane";			text_description = "";			text_id = "membrane";			num_id = Selectable.MEMBRANE;			bestColors = [false, false, true];			buttonMode = false;			updatePH(7.5);			CURR_NODES = 15;						has_health = true;			setMaxHealth(100, true);					}				include "inc_fastmath.as";				public override function destruct() {			removeEventListener(RunFrameEvent.RUNFRAME, churn);			membraneSprite.removeEventListener(MouseEvent.MOUSE_DOWN, doMouseDown);			membraneSprite.removeEventListener(MouseEvent.ROLL_OVER, doOver);			membraneSprite.removeEventListener(MouseEvent.ROLL_OUT, doOut);			membraneSprite.removeEventListener(Event.MOUSE_LEAVE, doOut);			membraneSprite.removeEventListener(MouseEvent.CLICK, click);			membraneSprite.removeChild(shape_spring);			membraneSprite.removeChild(shape_gap);			membraneSprite.removeChild(shape_outline);			removeChild(membraneSprite);			removeChild(shape_cyto);						destructNodes();			p_cent = null;			p_cell = null;			p_skeleton = null;			p_engine = null;			p_objectGrid = null;			super.destruct();		}				public override function init() {			super.init();			//list_shields = new Vector.<ShieldIcon>();			list_nodes = new Vector.<MembraneNode>();			list_viruses = new Vector.<Virus>();						iconSprite = new Sprite();						makeNodes(STARTING_RADIUS, STARTING_NODES);			tempTurnOffCentPullShort();			//MembraneNode.turnOffCentPull();						if(testNodeLinks()){				activateNodes();			}												membraneSprite = new Sprite();			membraneSprite.buttonMode = true;			membraneSprite.useHandCursor = true;						iconSprite.buttonMode = false;			iconSprite.useHandCursor = false;				shape_cyto = new Shape();			shape_spring = new Shape();			//shape_node = new Shape();						shape_gap = new Shape();			shape_outline = new Shape();									addChild(shape_cyto);			//addChild(shape_outline);									addChild(membraneSprite);			addChild(iconSprite);						membraneSprite.addChild(shape_outline);			membraneSprite.addChild(shape_spring);			membraneSprite.addChild(shape_gap);																	membraneSprite.addEventListener(MouseEvent.ROLL_OVER, doOver, false, 0, true);			membraneSprite.addEventListener(MouseEvent.ROLL_OUT, doOut, false, 0, true);			membraneSprite.addEventListener(Event.MOUSE_LEAVE, doOut, false, 0, true);			membraneSprite.addEventListener(MouseEvent.MOUSE_DOWN, doMouseDown, false, 0, true);			membraneSprite.addEventListener(MouseEvent.CLICK, click, false, 0, true);			addEventListener(RunFrameEvent.RUNFRAME, churn, false, 0, true);			//addEventListener(RunFrameEvent.FAUXFRAME, justDraw, false, 0, true);						shape_debug = new Shape()			addChild(shape_debug);						targetter = new Targetter();			addChild(targetter);			targetter.visible = false;						dummy_avgPoint = new Point();			dummy_midPoint = new Point();			dummy_midPoint2 = new Point();			dummy_lastPoint = new Point();			dummy_nextPoint = new Point();									//hideShields();						p_cell.onMembraneUpdate();		}						private function hideShields() {			//iconSprite.visible = false;			//shieldsOn = false;		}				private function showShields() {			/*trace("Membrane.showShields()!");			iconSprite.visible = true;			shieldsOn = true;			for each (var s:ShieldIcon in list_shields) {				s.setNum(Math.round(100 * defensin_strength));			}*/		}		public function getDefensins():Number {			return defensins;		}				public function getDefensinStrength():Number {			return defensin_strength;		}				public function removeDefensin(n:Number) {			defensins -= n;			calcDefensinStrength();			p_engine.oneLessDefensin(n);		}				private function calcDefensinStrength(){			defensin_strength = ( defensins / (list_nodes.length * MAX_DEFENSIN_PER_NODE) );			if (defensin_strength > MAX_DEFENSIN_STRENGTH) {				defensin_strength = MAX_DEFENSIN_STRENGTH;			}			p_engine.setDefensinStrength(defensin_strength);		}				public function addDefensin(n:Number){			defensins += n;			calcDefensinStrength();			p_engine.finishDefensin();			p_cell.onFinishDefensin();			//showShields();		}				private function destructNodes() {			var i:int = 0;			for each (var m:MembraneNode in list_nodes) {				m.destruct();				//removeChild(m);				list_nodes[i] = null;				i++;			}			list_nodes = null;		}				public function setObjectGrid(og:ObjectGrid) {			p_objectGrid = og;						MembraneNode.setGrid(og);		}				public function setCanvasGrid(og:ObjectGrid) {			p_cgrid = og;		}				public function updateGrid() {			for each(var m:MembraneNode in list_nodes) {				m.placeInGrid();			}						var length:int = list_viruses.length;			for (var i:int = 0; i < length; i++ ) {				if(list_viruses[i]){					if(!list_viruses[i].dying && !list_viruses[i].isDoomed){						list_viruses[i].placeInGrid();					}else {						list_viruses[i].clearGrid();						list_viruses[i] = null;						list_viruses.splice(i, 1);						i--;						length--;					}				}else {					list_viruses.splice(i, 1);					i--;					length--;				}			}			//length = list_		}				public function getClosestNodes(x:Number, y:Number, r2:Number):Vector.<MembraneNode> {			var v:Vector.<MembraneNode>;			for each(var m:MembraneNode in list_nodes) {				var x2:Number = m.x;				var y2:Number = m.y;				var dist2:Number = (((x - x2) * (x - x2)) + ((y - y2) * (y - y2)));				if (dist2 < r2) {					if (!v) { v = new Vector.<MembraneNode>(); }					v.push(m);									}			}			return v;		}				public function setSkeleton(s:Cytoskeleton) {			p_skeleton = s;		}				public function setCent(c:Centrosome) {			p_cent = c;		}				public function testNodeLinks():Boolean {			var done:Boolean = false;			var pass:Boolean = false;			var i:int = 0;			var theNode:MembraneNode;			var firstNode:MembraneNode;			firstNode = list_nodes[0];						while (!done){				theNode = list_nodes[i];		//get the next node (starts at 0)				if(i < list_nodes.length-1){	//if not at the end yet					if (theNode.p_next == list_nodes[i + 1]) {	//if the next node is ALSO the next one in the list						theNode = theNode.p_next;				//we're good, look at the next node					}				}else {					if (theNode.p_next == firstNode) { //if the next one is the first one						done = true;					//we are done						pass = true;					//we have passed					}					else{								done = true;					//we have failed						pass = false;					}				}				i++;	//increase the counter by one			}			return pass;		}				public function getCircum():Number {			return (list_nodes.length * MembraneNode.D_NODEREST);		}				public override function getRadius():Number {			return (list_nodes.length * MembraneNode.D_NODEREST) / (Math.PI*2)		}				private function activateNodes() {			//var length:int = list_nodes.length;									var distX:Number = list_nodes[0].x - list_nodes[0].p_next.x;			var distY:Number = list_nodes[0].y - list_nodes[0].p_next.y;			MembraneNode.D2_NODEREST = (distX * distX) + (distY * distY);			distX = x - list_nodes[0].p_cent.x;			distY = y - list_nodes[0].p_cent.y;			MembraneNode.D2_CENTREST = (distX * distX) + (distY * distY);			MembraneNode.D_NODEREST = Math.sqrt(MembraneNode.D2_NODEREST);			MembraneNode.D_CENTREST = Math.sqrt(MembraneNode.D2_CENTREST);		}				/**		 * Returns the index of the least stretched node		 * @return		 */				public function getMinStretchIndex():int {			var bestStretch:Number = 0;			var bestNode:int;			for (var j:int = 0; j < length; j++) {				if (list_nodes[j].stretch > bestStretch) {					bestStretch = list_nodes[j].stretch;					bestNode = j;				}			}			return bestNode;		}				/**		 * Returns the index of the most stretched node		 * @return		 */				public function getMaxStretchIndex():int {			var length:int = list_nodes.length;			var bestStretch:Number = 1;			var bestNode:int;			for (var j:int = 0; j < length; j++) {				if (list_nodes[j].stretch < bestStretch) {					bestStretch = list_nodes[j].stretch;					bestNode = j;				}			}			return bestNode;		}				public function canTakeMembrane():Boolean {			return (!waitForRecycle);		}				/**		 * Finds the least stretched node and removes it		 */				public function removeMembraneNodes(max:int,doUpdate:Boolean=true) {			waitForRecycle = true;			waitRecycleCounter = 0;			addEventListener(RunFrameEvent.RUNFRAME, waitForRecycleReady, false, 0, true);			for (var i:int = 0; i < max; i++) {				if(doUpdate && i==max-1){		//only do the update on the last one, if we're doing updates at all					removeMembraneNode(true);				}else {					removeMembraneNode(false);				}			}		}		 				private function removeMembraneNode(doUpdate:Boolean=true) {			var bestNode:int = getMinStretchIndex();			deleteMembraneNode(bestNode,doUpdate);			if (doUpdate) {				onChangeMembrane(true);			}			updateGrid();		}				private function onChangeMembrane(hardUpdate:Boolean=false) {			p_skeleton.newWarblePoints();						p_skeleton.updateAll();			p_cell.onMembraneUpdate(hardUpdate);			calcDefensinStrength();		}				private function onChangeNodes(i:int = 0) {			CURR_NODES = list_nodes.length;			var listlength:int = list_nodes.length;			var springDist:Number = MembraneNode.D_NODEREST;			var circumference:Number = springDist * (listlength+2); //+2 to fudge			var radius:Number = circumference / (TWOPI);			MembraneNode.getSprings(springDist, radius);			updateBasicUnitCollideDist();						updateMaxHealth(i);			//updateGrid();			//setMaxHealth(listlength * HEALTH_PER_NODE,true);		}				private function waitShortForCentPull(r:RunFrameEvent) {			wait_cent_count++;			if (wait_cent_count > WAIT_CENT_TIME_SHORT) {				wait_cent_count = 0;				removeEventListener(RunFrameEvent.RUNFRAME, waitShortForCentPull);				MembraneNode.turnOnCentPull();				readyForVesicle();			}		}				private function waitForCentPull(r:RunFrameEvent) {						wait_cent_count++;			if (wait_cent_count > WAIT_CENT_TIME) {				wait_cent_count = 0;				removeEventListener(RunFrameEvent.RUNFRAME, waitForCentPull);				MembraneNode.turnOnCentPull();				readyForVesicle();			}		}				/**		 * Finds the most stretched node and adds an extra node there		 */		public function addMembraneNode(doUpdate:Boolean = true) {			cancelPseudopod();			tempTurnOffCentPull();						var bestNode:int = getMaxStretchIndex();									insertMembraneNode(bestNode,doUpdate);						if (doUpdate) {				onChangeMembrane(true);			}						var length:Number = list_nodes.length;			for each(var m:MembraneNode in list_nodes) {				var v:Vector2D = new Vector2D(m.x-cent_x, m.y-cent_y);				v.normalize();				m.x += v.x * length; //extra "shove" to avoid crap				m.y += v.y * length;							}			updateGrid();		}				public function acceptVesicle() {			acceptingVesicles = false;		}				public function readyForVesicle() {			acceptingVesicles = true;		}				public function tempTurnOffCentPullShort() {			addEventListener(RunFrameEvent.RUNFRAME, waitShortForCentPull, false, 0, true);			MembraneNode.turnOffCentPull();		}				public function tempTurnOffCentPull() {						addEventListener(RunFrameEvent.RUNFRAME, waitForCentPull, false, 0, true);			MembraneNode.turnOffCentPull();		}				public function deleteMembraneNode(i:int, doUpdate:Boolean = true){						tempTurnOffCentPull();						var theNode:MembraneNode = list_nodes[i];			var prev:MembraneNode = list_nodes[i].p_prev;			var next:MembraneNode = list_nodes[i].p_next;						prev.p_next = next; //unhook it from the list, and hook up its pointers to eachother			next.p_prev = prev;						theNode.destruct(); //kill the node			list_nodes[i] = null;			list_nodes.splice(i, 1); //remove it from the list									var listlength:int = list_nodes.length;						for (var i:int = 0; i < listlength; i++) { //reorder everybody				list_nodes[i].index = i;			}						var length:Number = list_nodes.length;			for each(var m:MembraneNode in list_nodes) {				var v:Vector2D = new Vector2D(m.x-cent_x, m.y-cent_y);				v.normalize();				m.x += v.x * length; //extra "shove" to avoid crap				m.y += v.y * length;							}						if (doUpdate)				onChangeNodes(-1);		}				public function insertMembraneNode(i:int, doUpdate:Boolean = true):MembraneNode { //insert a new basal node after i			//trace("Membrane.insertMembraneNode(" + i + ")");						//WEIRD BUG: if the vesicle comes from the right, we get i = -1, throwing an out of range error			if (i < 0) {				i = 0;			}						var newNode:MembraneNode = interpolate(list_nodes[i], list_nodes[i].p_next,0.5);					var old:MembraneNode = list_nodes[i];			var oldNext:MembraneNode = list_nodes[i].p_next;									//OLD<--NEW-->OLDNEXT			newNode.p_prev = (old);			newNode.p_next = (oldNext);						//OLD-->NEW<--OLDNEXT			old.p_next = (newNode);			oldNext.p_prev = (newNode);						newNode.p_cent = (p_cent);									var listlength:Number = list_nodes.length;									list_nodes.splice(i+1, 0, newNode); //add it to the list									for (var i:int = 0; i < listlength; i++) { //reorder everybody				list_nodes[i].index = i;			}						if(doUpdate)				onChangeNodes(1);						return newNode;			//updateVolume();			//hookUpMicrotubules(p_skeleton.getTubes());					}				public override function getCircleVolume():Number {			var length:Number = list_nodes.length;			var rad:Number = (length * MembraneNode.D_NODEREST)/2;			cyto_volume = Math.PI * (rad * rad); // area, really, but whatever			return cyto_volume;		}				public function updateBasicUnitCollideDist() {			D2_BASIC_UNIT_COLLIDE = MembraneNode.D2_NODEREST;			D_BASIC_UNIT_COLLIDE = Math.sqrt(D2_BASIC_UNIT_COLLIDE);		}				public function onSkeletonReady() {			if (!skeletonReady) {				addEventListener(RunFrameEvent.RUNFRAME, waitForReady,false,0,true);				skeletonReady = true;				giveMaxHealth();			}		}		public function waitForRecycleReady(r:RunFrameEvent) {			waitRecycleCounter++;			if (waitRecycleCounter > 30) {				waitRecycleCounter = 0;				removeEventListener(RunFrameEvent.RUNFRAME, waitForRecycleReady);				waitForRecycle = false;			}		}				public function waitForReady(r:RunFrameEvent) {			waitCounter++;			if(waitCounter > 3){				removeEventListener(RunFrameEvent.RUNFRAME, waitForReady);				skeletonReady = true;			}		}				public function updateViruses(list:Vector.<Virus>) {			list_viruses = list.concat();		}				public function updateBasicUnits(list:Vector.<BasicUnit>) {			list_basicUnits = list.concat();		}				public function updateGravPoints(list:Vector.<GravPoint>, list_blank:Vector.<GravPoint>=null) {						list_grav = list.concat();						if (list_blank != null) {				list_grav_blank = list_blank.concat();			}		}				/*public function hookUpMicrotubules(list_tubes:Vector.<Microtubule>) {			//trace("hook up microtubules!!!!!");			var length:Number = list_nodes.length;			for (var i:int = 0; i < length; i++) {				nodeGetsTube(list_nodes[i],list_tubes);			}					}*/				/*public function nodeGetsTube(m:MembraneNode,list_tubes:Vector.<Microtubule>) {						var bestTube:Microtubule = null;			var bestDist2:Number = 100000000000000000000;			var currDist2:Number = bestDist2;						var length = list_tubes.length;			for (var j:int = 0; j < list_tubes.length; j++) {				var distX:Number = m.x - (list_tubes[j].x+list_tubes[j].lastX());				var distY:Number = m.y - (list_tubes[j].y+list_tubes[j].lastY());				currDist2 = ((distX * distX) + (distY * distY));				if (currDist2 < bestDist2) {					bestTube = list_tubes[j];					bestDist2 = currDist2;				}			}						if (bestTube) {				m.setMicrotubule(bestTube);			}else {							}		}*/				public function interpolate(n1:MembraneNode, n2:MembraneNode, f:Number):MembraneNode{			if (f > 1) f = 1;			else if (f < 0) f = 0;									var p = Point.interpolate(new Point(n1.x, n1.y), new Point(n2.x, n2.y), f);			var rot:Number = (n1.rotation * f) + (n2.rotation * (1 - f));			var n:MembraneNode = createNode(p.x, p.y, rot, -1);									/*new MembraneNode();			n.p_membrane = this;			n.x = p.x;			n.y = p.y;			n.p_cent = this.p_cent;			n.rotation = (n1.rotation * f) + (n2.rotation * (1 - f));			n.init();*/			return n;		}				public function getPopPoints():Array {			var points:Array = new Array();			var radii:Array = new Array();			var g:GravPoint;			/*for each(g in list_grav) {				points.push(new Point(1.5*g.x+cent_x, 1.5*g.y+cent_y));				radii.push(g.radius);			}			for each(g in list_grav_blank) {				points.push(new Point(1.5*g.x+cent_x, 1.5*g.y+cent_y));				radii.push(g.radius);			}*/						var centrad:Number = p_skeleton.cent_radius;			var splashNum:Number = 20;			var splashSize:Number = (centrad*4) / splashNum;			var v:Vector.<Number> = p_engine.getSpiralPoints(new Point(cent_x, cent_y), splashNum, splashSize);			var vlength:int = v.length;			var scale:Number;			for (i = 0; i < vlength; i+=2) {				points.push(new Point(v[i], v[i + 1]));				scale = Math.random() + 1; //between 1 & 2				radii.push(splashSize * scale);			}						for each(var n:MembraneNode in list_nodes) {				if (i % 2 == 0) {					points.push(new Point(n.x, n.y));					scale = Math.random() + 1; //between 0.5 & 1.5					radii.push(35 * scale); //magic number!				}			}			var i:int = 0;			/*for each(var n:MembraneNode in list_nodes) {				//if(i % 2 == 0){	//also, every other membrane node					points.push(new Point(n.x+cent_x, n.y+cent_y));					radii.push(100); //magic number!				//}				//i++;			}*/			points.reverse(); //so it will look prettier			radii.reverse();			return [points, radii];					}				private function makeNodes(radius:Number, max:int) {						 var v:Vector.<Number> = circlePoints(radius, max);			 var length:int = v.length;			 var rot:Number = 0;			 for (var i:int = 0; i < length; i+=2) {				rot = 90 + ( (i/2) * (360 / max) );				makeNode(v[i], v[i + 1], rot, i / 2, max - 1); //do max-1 so that it knows that that's the last index in the list											 }			 		}				private function createNode(xx:Number, yy:Number, r:Number, i:int):MembraneNode {			var n:MembraneNode = new MembraneNode();			n.x = xx;			n.y = yy;			n.rotation = r;			n.p_cent = p_cent;			n.p_membrane = this;			n.index = i;			n.init();						/*if(shieldCounter >= NODES_PER_SHIELD){				createShield();				shieldCounter = 0;			}			shieldCounter++;*/						return n;		}				private function createShield() {			/*var s:ShieldIcon = new ShieldIcon();			list_shields.push(s);			iconSprite.addChild(s);			trace("Membrane.createShield()! list_shields.length = " + list_shields.length);			if (shieldsOn) {  				showShields();					   //match the numbers				s.scaleX = list_shields[0].scaleX; //match the scale				s.scaleY = list_shields[1].scaleY;			}*/		}				private function makeNode(xx:Number, yy:Number, r:Number, i:int, max:int) {			var n:MembraneNode = createNode(xx, yy, r, i);			list_nodes.push(n);			linkNode(i, max);		}				private function linkNode(i:int,max:int){			if(i > 0){ //don't link the first one				list_nodes[i].p_prev = list_nodes[i - 1];				list_nodes[i - 1].p_next = list_nodes[i];			}								if (i == max) {//once we arrive at the last one, link the first one				list_nodes[i].p_next = (list_nodes[0]);				list_nodes[0].p_prev = (list_nodes[i]);			}		}				protected override function click(m:MouseEvent) {			//trace("Membrane : Clicked at" + m.localX + "," + m.localY + "VS" + mouseX + "," + mouseY);			if(isMouseDown){				/*var a:Array = Costs.BLEB;				if (isMouseOver) {					if(p_engine.spend(a)){						tryBleb(m.localX, m.localY);					}				}*/				isMouseDown = false;			}		}				private function justDraw(e:RunFrameEvent) {					}				private function churn(e:RunFrameEvent) {			updateHealth();			updateNodes();		}				public function takeDamageAt(xx:Number,yy:Number,n:Number) {			super.takeDamage(n);			p_cell.makeStarburst(xx, yy);onHealthChange();			//trace("Membrane.takeDamageAt(" + n + ") health=" + health + "/" + maxHealth);		}				protected override function onDamageKill() { 			//override damagekill for the membrane			if(!p_cell.isCellDying){				p_cell.startNecrosis(); //we are TOAST!			}		}				public function onHealthChange() {			p_cell.onMembraneHealthChange(health);		}				public function updateMaxHealth(changeNodes:int = 0, fillUp:Boolean = false) {			var listlength:int = list_nodes.length;			var extra:int = listlength - STARTING_NODES;						if(changeNodes > 0){				if (extra > 0) {					setMaxHealth(100 + (extra * HEALTH_PER_NODE), fillUp);					if (changeNodes > 0 && changeNodes <= extra) {						giveHealth(changeNodes * HEALTH_PER_NODE);					}				}			}else if (changeNodes < 0) {				if(extra >= 0){					setMaxHealth(100 + (extra * HEALTH_PER_NODE), false);				}			}									onHealthChange();			//setMaxHealth(listlength * HEALTH_PER_NODE,true);					}				public override function giveHealth(amt:uint) {						health += amt;			if (health > maxHealth) {				health = maxHealth;			}		}				public function updateHealth() {			healthCounter++;			if (healthCounter > HEALTH_COUNT) {				healthCounter = 0;								if(health < maxHealth){					if (p_cell.spendATP(Costs.FIX_MEMBRANE)) {						giveHealth(1);					}				}								var frac:Number = Number(health) / Number(maxHealth);								health_col = Color.interpolateColor(0xFF0000, spring_col, frac);				health_col2 = Color.interpolateColor(0xFFCC99, gap_col, frac);				onHealthChange();			}		}				public function onStartPPod() {			isPPoding = true;		}				public function onFinishPPod() {			isPPoding = false;			p_engine.notifyOHandler(EngineEvent.EXECUTE_ACTION, null, "pseudopod_finish", 1);		}				private function cancelPseudopod() {			p_skeleton.cancelPseudopod();		}				public override function doCellMove(xx:Number, yy:Number) {			for each(var m:MembraneNode in list_nodes) {				m.doCellMove(xx, yy);			}		}				private function tryPseudopod(xx:Number, yy:Number) {			var dx:Number = cent_x - xx;			var dy:Number = cent_y - yy;			var d2:Number = (dx * dx) + (dy * dy);			d2 /= Costs.MOVE_DISTANCE2;			var cost:Number = Costs.PSEUDOPOD[0] * d2;			if (p_engine.canAfford(cost, 0, 0, 0, 0)) {				p_skeleton.cancelPseudopod(); //only 1 ppod at once!				p_skeleton.tryPseudopod(xx, yy, cost);			}else{				p_engine.showImmediateAlert(Messages.A_NO_AFFORD_PPOD);			}					}				/*private function ppodBleb(xx:Number, yy:Number) {			var bestM:MembraneNode = findClosestMembraneNode(xx, yy);			bestM.doPpod(1);		}				private function tryBleb(xx:Number,yy:Number,v:Vector2D = null) {			var bestM:MembraneNode = findClosestMembraneNode(xx, yy);			bestM.doBleb(2,v);		}*/		/**		 * Give me your position, I'll return the node where (mnode.pos+mnode.p_next.pos)/2 is closest to it		 * @param	xx		 * @param	yy		 * @return		 */				public function findClosestMembraneHalf(xx:Number, yy:Number):MembraneNode {			var bestM:MembraneNode = null;			var bestD2:Number = 10000000000000000;			var length:int = list_nodes.length;			for (var i:int = 0; i < length; i++) {								var xpos:Number = (list_nodes[i].x + list_nodes[i].p_next.x) / 2;				var ypos:Number = (list_nodes[i].y + list_nodes[i].p_next.y) / 2;								var xdist:Number = (xpos - xx);				var ydist:Number = (ypos - yy);								var dist2:Number = (xdist * xdist) + (ydist * ydist);								if (dist2 < bestD2) {					bestD2 = dist2;					bestM = list_nodes[i];				}			}			return bestM;		}				/**		 * Give me your position, I'll return the closest node to it		 * @param	xx		 * @param	yy		 * @return		 */				public function findClosestMembraneNode(xx:Number, yy:Number):MembraneNode {			var bestM:MembraneNode = null;			var bestD2:Number = 10000000000000000;			var length:int = list_nodes.length;			for (var i:int = 0; i < length; i++) {				//var xdist:Number = (list_nodes[i].x+cent_x - xx);				var xdist:Number = (list_nodes[i].x - xx);				//var ydist:Number = (list_nodes[i].y+cent_y - yy);				var ydist:Number = (list_nodes[i].y - yy);				var dist2:Number = (xdist * xdist) + (ydist * ydist);				if (dist2 < bestD2) {					bestD2 = dist2;					bestM = list_nodes[i];				}			}			return bestM;		}				/*public function collisionTest(gp:Vector.<Point>) {			var isCollide:Boolean = false;			for (var i:int = 0; i < gp.length; i++) {								if (collide(gp[i])) {					isCollide = true;				}			}			if (isCollide) {				has_collided = true;			}else {				has_collided = false;			}		}*/				private function quickCircSeg(c:Vector2D, r:Number, p1:Vector2D, p2:Vector2D, m:MembraneNode):Boolean{						var dir:Vector2D = p2.subtractedBy(p1);			var diff:Vector2D = c.subtractedBy(p1);			var frac:Number = diff.dotOf(dir);			var mag:Number = dir.dotOf(dir);			var t:Number = frac / mag;			if (t < 0) t = 0;			if (t > 1) t = 1;			var pushBit:Vector2D = dir.multipliedBy(t);			var closest:Vector2D = p1.addedTo(pushBit);			var d:Vector2D = c.subtractedBy(closest);			var distsqr:Number = d.dotOf(d);						if (distsqr < (r * r)) {				return true;			}			return false;		}				private function quickCircSeg2(c:Vector2D, r:Number, p1:Vector2D, p2:Vector2D, m:MembraneNode):Number{						var dir:Vector2D = p2.subtractedBy(p1);			var diff:Vector2D = c.subtractedBy(p1);			var frac:Number = diff.dotOf(dir);			var mag:Number = dir.dotOf(dir);			var t:Number = frac / mag;			if (t < 0) t = 0;			if (t > 1) t = 1;			var pushBit:Vector2D = dir.multipliedBy(t);			var closest:Vector2D = p1.addedTo(pushBit);			var d:Vector2D = c.subtractedBy(closest);			penetrate_vector = d.copy();			penetrate_vector.multiply(0.5);			penetrate_unit_vector = penetrate_vector.getNormalized();			//penetrate_vector.normalize();			var distsqr:Number = d.dotOf(d);			var pen2:Number = (distsqr - (r * r));			/*if (debug) {				trace("Membrane.quickCircSeg2() penetrate_vector = " + penetrate_vector);			}*/			return pen2;		}				private function intersectCircleSegment(obj:CellObject, c:Vector2D, r:Number, p1:Vector2D, p2:Vector2D, m:MembraneNode):Boolean 		{			var dir:Vector2D = p2.subtractedBy(p1);			var diff:Vector2D = c.subtractedBy(p1);			var frac:Number = diff.dotOf(dir);			var mag:Number = dir.dotOf(dir);			var t:Number = frac / mag;			if (t < 0) t = 0;			if (t > 1) t = 1;			var pushBit:Vector2D = dir.multipliedBy(t);			var closest:Vector2D = p1.addedTo(pushBit);			var d:Vector2D = c.subtractedBy(closest);			var distsqr:Number = d.dotOf(d);			if (distsqr < (r * r)) {				var penetrate:Number = r - d.length;				var unitd:Vector2D = d.getNormalized();				var pushd:Vector2D = unitd.multipliedBy(penetrate);				//trace("Membrane.intersectCircleSegment()! pushD = " + pushd);								m.x -= pushd.x;				m.y -= pushd.y;				m.p_next.x -= pushd.x;				m.p_next.y -= pushd.y;											if (obj) {					if (!(obj is Microtubule) && !(obj is Centrosome) && !(obj is Nucleus)) { //if its an object						obj.push(pushd.x, pushd.y);							obj.cancelMove();					}				}				return true;			}			return false;		}				/**		 * This function keeps everything happy. It is big, it is ugly, but for the most part, it works.		 * @param	i		 */				public function collisionTest(i:int) {			var m1:MembraneNode = list_nodes[i];			var m2:MembraneNode = list_nodes[i].p_next;			var p1:Vector2D = new Vector2D(m1.x,m1.y);			var p2:Vector2D = new Vector2D(m2.x, m2.y);						var yes:Boolean = false;			var dist:Number;			var dist2:Number;						//First, check the canvas neighbors						var neighbors:Vector.<GameDataObject> = p_cgrid.getNeighbors(m1.grid_x, m1.grid_y)			for each(var gdo:GameDataObject in neighbors) {				var cv:CanvasObject = CanvasObject(gdo.ptr);				if (cv) {					if (cv is GoodieGem) {						dist2 = quickCircSeg2(new Vector2D(cv.x, cv.y), cv.getRadius(), p1, p2, m1);						if (dist2 < 0) {							GoodieGem(cv).onTouchCell2(dist2,penetrate_unit_vector);						}					}else if (quickCircSeg(new Vector2D(cv.x, cv.y), cv.getRadius(), p1, p2, m1)) {						if (cv is CanvasWrapperObject) {							if (CanvasWrapperObject(cv).c_cellObj is BigVesicle) {								mergeVesicle(CanvasWrapperObject(cv), m1, m2);							}						}						cv.onTouchCell();					}				}			}						//Next, test the cell neighbors						var vNeighbors:Vector.<GameDataObject> = GameObject.p_grid.getNeighbors(m1.grid_x, m1.grid_y);			for each(var gdo_:GameDataObject in vNeighbors){				var go:IGameObject = IGameObject(gdo_.ptr);				var c:CellObject;				if(go){					if (go is Virus) {						var v:Virus = Virus(go);												//Check to see if the virus is INSIDE the cell and NOT trying to escape						//If so, we need to make its collision behaving!						if (v.position_state == Virus.POS_INSIDE_CELL && v.motivation_state != Virus.MOT_ESCAPING_CELL) {							//THIS IS AN UGLY HACK BUT IT MAKES THINGS WORK:							dist2 = quickCircSeg2(new Vector2D(v.x, v.y), v.getRadius(), p1, p2, m1);							if (dist2 < 0) {																var ddx:Number = v.x - cent_x;								var ddy:Number = v.y - cent_y;																var dmx:Number = (m1.x + m2.x) / 2 - cent_x;								var dmy:Number = (m1.y + m2.y) / 2 - cent_y;																var dd2:Number = ddx * ddx + ddy * ddy;								var dm2:Number = dmx * dmx + dmy * dmy;																//CHECK TO SEE IF I'M ACTUALLY INSIDE MEMBRANE. 								//If so, push to keep me there.								//If not, let me in!!!!																if(dd2 < dm2){									v.push(penetrate_vector.x, penetrate_vector.y); //push away from membrane									if (m1.state_ppod) {				//push away from pseudopoding membrane										v.push(m1.xdist, m1.ydist);									}									if (m2.state_ppod) {										v.push(m2.xdist, m1.ydist);									}								}							}						}else if (v.position_state != Virus.POS_INSIDE_CELL) {							if (quickCircSeg(new Vector2D(v.x, v.y), v.getRadius(), p1, p2, m1)) {								//This is the normal case, if it's not inside & not escaping, check to see if it's touching the cell membrane								v.onTouchCell();							}						}					}else if (go is HardPoint) {						c = CellObject(go);						if (intersectCircleSegment(null, new Vector2D(c.x, c.y), c.getRadius(), p1, p2, m1)) {							yes = true;						}					}else if (go is CellObject) {						c = CellObject(go);						var doTest:Boolean = false;						if (c is BasicUnit) {							if (BasicUnit(c).doesCollide && BasicUnit(c).might_collide) {								doTest = true;							}						}else if(c.doesCollide){							doTest = true;						}						if (doTest) {							var showLyso:Boolean = false;							if (c is Lysosome) {								showLyso = true;							}							dist2 = quickCircSeg2(new Vector2D(c.x, c.y), c.getRadius(), p1, p2, m1);							if (dist2 < 0) {								if (c.isMoving){ 														c.cancelMove();								}								c.push(penetrate_vector.x, penetrate_vector.y);								if (m1.state_ppod) {									c.push(m1.xdist, m1.ydist);								}								if (m2.state_ppod) {									c.push(m2.xdist, m1.ydist);								}							}								}					}				}			}			for each(var gg:GravPoint in list_grav_blank) {				if (gg) {					c = gg.p_obj;					if (intersectCircleSegment(c, new Vector2D(gg.x, gg.y), gg.radius, p1, p2, m1)) {						m1.state_ppod = true; //if I'm touching a ppod ball, I'm ppoding!						m1.p_prev.state_ppod = true;						m1.p_next.state_ppod = true;						yes = true;					}else {						m1.state_ppod = false;					}				}			}						if (yes) {				m1.has_collided = true;			}else {				m1.has_collided = false;			}		}				public function mergeVesicle(cw:CanvasWrapperObject, m1:MembraneNode, m2:MembraneNode) {			var content:String = cw.content;			var xx:Number = cw.x;			var yy:Number = cw.y;			var rad:Number = cw.getRadius();			var m:MembraneNode = findClosestMembraneHalf(xx, yy);			var p:Point = new Point((m.x + m.p_next.x) / 2, (m.y + m.p_next.y) / 2);			var v:Vector2D = new Vector2D(xx - p.x, yy - p.y); //vector from vesicle center to node						//since the vesicle is TOUCHING the cell, then the magnitude of v is ALWAYS very close to the radius of the vesicle												//multiplying the vector by 2 will get the diameter			/*m.x -= v.x; //create the illusion of merging the vesicle			m.y -= v.y;						m.p_next.x -= v.x;			m.p_next.y -= v.y;*/															//m.p_prev.x						/*m.p_prev.x -= v.x * 1.5;			m.p_prev.y -= v.y * 1.5;						m.p_next.p_next.x -= v.x * 1.5;			m.p_next.p_next.y -= v.y * 1.5;*/						//m.p_prev.x -= v.x;			//m.p_prev.y -= v.y;			//v.normalize();									/*var numNodes:Number = Math.round(2*rad*Math.PI / MembraneNode.D_NODEREST);			//trace("Membrane.mergeVesicle() numNodes = " + numNodes);			//var v:Vector2D = new Vector2D(			var m:MembraneNode = insertMembraneNode(m1.index); //insert a new node after m1 - right in the middle			var v2:Vector2D = new Vector2D(cw.x-m.x,cw.y-m.y); //vector from vesicle center to midpoint of nodes			v2.normalize();									   //unit vector pointing from the vesicle center to the midpoing			v2.multiply(Cytoskeleton.GRAV_RADIUS * 4); 		   //multiply it times (LOTS) the radius of the grav point of an organelle			//v2.multiply(2);			var twopi:Number = Math.PI * 2;			//We're now going to create a "bubble" of membrane by rotating v2 around, adding membrane nodes at those points,			//and ending at the midpoint where we inserted our first node			for (var i:int= 1; i <= numNodes; i++) {				m = insertMembraneNode(m.index); //insert a new one after the last one				v2.rotateVector( -twopi / numNodes);				m.x = cw.x + v2.x; //				m.y = cw.y + v2.y;			}*/			var vCent:Vector2D = new Vector2D(cw.x - cent_x, cw.y - cent_y); //vector from vesicle center to the centrosome			vCent.normalize();				//unit vector in the direction of the centrosome			cancelPseudopod();			/*if (m1.state_ppod || m2.state_ppod) {				vCent.multiply(-rad*5)			}else{*/			vCent.multiply(-rad*3); 			//shove it towards the centrosome			//}			//throw new Error("Let's see!");			p_cell.makeVesicleContent(content, cw.x + vCent.x, cw.y + vCent.y); //make the thing, shoved slightly towards the centrosome						//p_cell.killCanvasObject(cw);			//removeMembraneNodes(2);		}				/*public function collide(c:Point) {			v_grav.Set(c.x - x, c.y - y);			var dist:Number = v_grav.length;			//trace("dist = " + dist);			if (dist < 100) {				var frac = (100 - dist) / 100;				x -= v_grav.x * frac;				y -= v_grav.y * frac;				return true;			}			return false;		}*/						public function updatePH(ph:Number) {			//ph_balance = ph;			//updateColors();		}				private function updateColors() {			//cyto_col = 0x8833CC;// PH.getCytoColor(ph_balance_show);			//spring_col = 0x663399;// PH.getLineColor(ph_balance_show);			//gap_col = 0xBB99FF;// PH.getGapColor(ph_balance_show);		}				private function animatePH() {			/*if (ph_balance_show < ph_balance - 0.1) {				ph_balance_show += 0.1;			}else if (ph_balance_show > ph_balance + .1) {				ph_balance_show -= 0.1;			}else {				ph_balance_show = ph_balance;			}			updateColors();*/		}						private function updateNodes() {			var i:int = 0;						MembraneNode.tug_x = 0;			MembraneNode.tug_y = 0;						var length:int = list_nodes.length;			var avg_stretch:Number = 0;			for (i = 0; i < length; i++) {				if(skeletonReady){					list_nodes[i].updateDist();					list_nodes[i].doMove();					collisionTest(i); 					avg_stretch += list_nodes[i].stretch;				}			}			AVG_STRETCH = avg_stretch/length;					drawAllNodes(true);					p_skeleton.x += MembraneNode.tug_x;			p_skeleton.y += MembraneNode.tug_y;		}				public function drawAllNodes(doTug:Boolean=false) {			shape_spring.graphics.clear();			shape_cyto.graphics.clear();			shape_gap.graphics.clear();			shape_outline.graphics.clear();			shape_debug.graphics.clear();						startCyto();							shape_spring.graphics.lineStyle(SPRING_THICK, health_col);// , false, "normal", CapsStyle.ROUND);			shape_gap.graphics.lineStyle(GAP_THICK, health_col2);			shape_outline.graphics.lineStyle(OUTLINE_THICK, 0x000000);									var length:int = list_nodes.length;			for (var i:int = 0; i < length; i++) {				if (skeletonReady) {					if (doTug) {						list_nodes[i].tugNodes();					}					drawMembrane(list_nodes[i]);// , c, c2);				}			}			endCyto();		}				public function startCyto() {			shape_cyto.graphics.beginFill(cyto_col, 1);			/*shape_cyto.graphics.moveTo(list_nodes[0].p_prev.x, list_nodes[0].p_prev.y);			if(list_nodes.length >= 1) //Optimize (keep track of length once and remember)				shape_cyto.graphics.lineTo(list_nodes[0].x, list_nodes[0].y);*/			var m:MembraneNode = list_nodes[0];			if(list_nodes.length >=1){				var mid:Point = new Point(						(m.pt_control_next.x + m.p_next.pt_control_prev.x) / 2,						(m.pt_control_next.y + m.p_next.pt_control_prev.y) / 2);				shape_cyto.graphics.moveTo(mid.x, mid.y);			}		}				public function endCyto() {			/*if (list_nodes.length >= 1) //Optimize 			{				shape_cyto.graphics.lineTo(list_nodes[0].x, list_nodes[0].y);			}*/			var m:MembraneNode = list_nodes[0];			if (list_nodes.length >= 1) {				var mid:Point = new Point(						(m.pt_control_next.x + m.p_next.pt_control_prev.x) / 2,						(m.pt_control_next.y + m.p_next.pt_control_prev.y) / 2);				if (DRAW_QUALITY == DRAW_CURVES) {					shape_cyto.graphics.lineTo((mid.x + m.x) / 2, (mid.y + m.y) / 2);				}				shape_cyto.graphics.lineTo(mid.x, mid.y);			}			shape_cyto.graphics.endFill();					}				public override function updateBubbleZoom(n:Number) {			super.updateBubbleZoom(n);						if (SPRING_THICK_*n < SPRING_MIN) 				SPRING_THICK = SPRING_MIN / n;			else				SPRING_THICK = SPRING_THICK_;									if (GAP_THICK_*n < GAP_MIN) 				GAP_THICK = GAP_MIN / n;			else				GAP_THICK = GAP_THICK_;						if (OUTLINE_THICK_*n < OUTLINE_MIN) 				OUTLINE_THICK = OUTLINE_MIN / n;			else				OUTLINE_THICK = OUTLINE_THICK_;						/*for each(var s:ShieldIcon in list_shields) {				s.scaleX = 1 / n;				s.scaleY = 1 / n;			}*/									/*scaleX = 1/n;			scaleY = 1/n;*/		}						public function drawMembrane(m:MembraneNode){//, c:uint, c2:uint) {						var mid_prev:Point = new Point(						(m.pt_control_prev.x + m.p_prev.pt_control_next.x) / 2,						(m.pt_control_prev.y + m.p_prev.pt_control_next.y) / 2);						var mid:Point = new Point(						(m.pt_control_next.x + m.p_next.pt_control_prev.x) / 2,						(m.pt_control_next.y + m.p_next.pt_control_prev.y) / 2);						/*if (shieldsOn) {				if (m.index % NODES_PER_SHIELD == 0) {					var index:int = m.index / NODES_PER_SHIELD;					var s:ShieldIcon = list_shields[m.index/NODES_PER_SHIELD];					s.x = m.x;					s.y = m.y;				}							}*/						var dx:Number = mid_prev.x - mid.x;			var dy:Number = mid_prev.y - mid.y;			var d2:Number = (dx * dx) + (dy * dy);									if (d2 < MembraneNode.D2_NODEREST / 10) {				//super hacky hack!				m.isFolded = true;				//this is not elegant code!				dummy_flag = true;			}else {				m.isFolded = false;				endDummy = true;			}					if(DRAW_QUALITY == DRAW_CURVES){ //curves				//THE NORMAL WAY OF DOING THINGS:				if(!dummy_flag){					shape_spring.graphics.moveTo(mid_prev.x, mid_prev.y);					shape_gap.graphics.moveTo(mid_prev.x, mid_prev.y);					shape_outline.graphics.moveTo(mid_prev.x, mid_prev.y);										shape_spring.graphics.curveTo(m.x, m.y, mid.x, mid.y);						shape_gap.graphics.curveTo(m.x, m.y, mid.x, mid.y);					shape_outline.graphics.curveTo(m.x, m.y, mid.x, mid.y);										shape_cyto.graphics.lineTo((mid.x + m.x) / 2, (mid.y + m.y) / 2);					shape_cyto.graphics.lineTo(mid.x, mid.y);				}else {						shape_spring.graphics.moveTo(mid_prev.x, mid_prev.y);					shape_gap.graphics.moveTo(mid_prev.x, mid_prev.y);					shape_outline.graphics.moveTo(mid_prev.x, mid_prev.y);										shape_spring.graphics.lineTo(mid.x, mid.y);					shape_gap.graphics.lineTo(mid.x, mid.y);					shape_outline.graphics.lineTo(mid.x, mid.y);										shape_cyto.graphics.lineTo(mid.x, mid.y);					}			}else if (DRAW_QUALITY == DRAW_LINES) { //lines				shape_spring.graphics.moveTo(mid_prev.x, mid_prev.y);				shape_gap.graphics.moveTo(mid_prev.x, mid_prev.y);				shape_outline.graphics.moveTo(mid_prev.x, mid_prev.y);														shape_spring.graphics.lineTo(mid.x, mid.y);					shape_gap.graphics.lineTo(mid.x, mid.y);				shape_outline.graphics.lineTo(mid.x, mid.y);				shape_cyto.graphics.lineTo(mid.x, mid.y);			}													if(SHOW_NODES){				/*shape_debug.graphics.lineStyle(0, 0);				shape_debug.graphics.drawCircle(m.x, m.y, D_NODECLICK);				shape_debug.graphics.drawCircle(mid.x, mid.y, D_MNODECLICK);*/								/*if (m.state_bleb) {					shape_debug.graphics.beginFill(0x00FFFF);				}else if (m.state_blebcontract) {					shape_debug.graphics.beginFill(0x008888);				}else */				if (m.state_ppod) {					shape_debug.graphics.beginFill(0xFF0000);				}else if(dummy_flag){					shape_debug.graphics.beginFill(0xFF00FF);				}else {					shape_debug.graphics.beginFill(0xFFFFFF);				}				shape_debug.graphics.drawCircle(m.x, m.y, 10);				shape_debug.graphics.drawCircle(mid.x, mid.y, 5);				shape_debug.graphics.drawCircle(mid_prev.x, mid_prev.y, 5);				shape_debug.graphics.endFill();			}						if (endDummy) {				dummy_flag = false;			}						if (SHOW_GRAVPOINTS) {				var colorz:uint = 0xFF0000;				shape_debug.graphics.lineStyle(3, 0x0000FF, 1);				for (var i:int = 0; i < list_grav.length; i++) {					shape_debug.graphics.drawCircle(list_grav[i].x, list_grav[i].y, list_grav[i].radius);				}								shape_debug.graphics.lineStyle(3, 0xFFFFFF, 1);				for (var j:int = 0; j < list_grav_blank.length; j++) {					shape_debug.graphics.drawCircle(list_grav_blank[j].x, list_grav_blank[j].y, list_grav_blank[j].radius);				}							}		}						/*public function drawTubeSprings(m:BasalNode) {			if (Game.SHOWLINES) {				if(Game.DEBUG){					if (!b.tubeRest) {						if(b.centD > 0)							springShape.graphics.lineStyle(1, 0x00FF00, 0.5);						else								springShape.graphics.lineStyle(1, 0xFF0000, 1);											}				}else {						springShape.graphics.lineStyle(1, 0xFFFFFF, 1);				}				if(b.tube){					springShape.graphics.moveTo(b.x, b.y);					springShape.graphics.lineTo(b.tubePoint.x, b.tubePoint.y);				}			}else {				//don't show any lines			}		}*/				public function drawCentralSprings(m:MembraneNode){			if (SHOWLINES) {				if(DEBUG){					if (!m.rest_cent) {						if(m.dpull_cent > 0)							shape_spring.graphics.lineStyle(1, 0x00FF00, 0.5);						else								shape_spring.graphics.lineStyle(1, 0xFF0000, 1);											}				}else {						shape_spring.graphics.lineStyle(1, 0x55CCFF, 1);				}				shape_spring.graphics.moveTo(m.x, m.y);				shape_spring.graphics.lineTo(m.p_cent.x, m.p_cent.y);			}else {				//don't show any lines			}		}				public override function setEngine(e:Engine) {			p_engine = e;		}				public function clearMouse() {			if (isMouseDown) {				isMouseDown = false;				hideCursor();				hidePPodCursor();				removeEventListener(RunFrameEvent.RUNFRAME, doMouseMove);			}		}				private function doMouseUp() {			if (isMouseDown) {				var xd:Number = mouseX - mouseDown_x;				var yd:Number = mouseY - mouseDown_y;				d2_mouse = (xd * xd) + (yd * yd);				if (d2_mouse > D2_PPOD) {					tryPseudopod(mouseX, mouseY);					hidePPodCursor();				}			}			isMouseDown = false;			hideCursor(); //go back from the bleb cursor to nothing			removeEventListener(RunFrameEvent.RUNFRAME, doMouseMove);		}				private function hideTargetter() {			targetter.visible = false;		}				public function onCellMove(xx:Number, yy:Number) {			targetter.x -= xx;			targetter.y -= yy;			mouseDown_x -= xx;			mouseDown_y -= yy;		}				private function showTargetter() {									var m:Vector.<MembraneNode> = getClosestNodes(mouseDown_x, mouseDown_y, D2_PPOD);			if(m){				//BUG ALERT				//BUG ALERT: This assumes that the membrane is at 0,0 without scale!				worldScale = p_engine.getWorldScale();				targetter.scaleX = 1/worldScale; //There's going to be bugs unless you update this whenever you change scale!				targetter.scaleY =  1/worldScale;				targetter.visible = true;				targetter.x = mouseDown_x;				targetter.y = mouseDown_y;				p_engine.setCursorArrowPoint(mouseDown_x, mouseDown_y);				if (m.length > 1) {					var mm:MembraneNode = m.pop();					p_engine.setCursorArrowRotation(mm.rotation);				}			}		}						private function doMouseDown(m:MouseEvent) {						isMouseDown = true;			mouseDown_x = m.localX;			mouseDown_y = m.localY;			//p_cell.dispatchEvent(m);			addEventListener(RunFrameEvent.RUNFRAME, doMouseMove, false, 0, true);			m.stopPropagation(); //keep it from going to the cell			p_engine.dispatchEvent(m); //send it directly to the engine			//m.stopImmediatePropagation();			//trace("Membrane.doMouseDown()! isMouseDown = " + isMouseDown);		}				private function doMouseMove(e:RunFrameEvent) {			if (isMouseDown) {				if (Director.IS_MOUSE_DOWN == false) { //CHEAP HACK : "Release Outside" event - just check every frame against global					doMouseUp();				}else{					var xd:Number = mouseX - mouseDown_x;					var yd:Number = mouseY - mouseDown_y;					d2_mouse = (xd * xd) + (yd * yd);					//trace("Membrane.doMouseMove()! d2_mouse = " + d2_mouse + " D2_PPOD = " + D2_PPOD);					if (d2_mouse >= D2_PPOD) {						showPPodCursor();						//trace("Membrane.doMouseMove()! SHOW SHOW SHOW showPPod!");					}else{						hidePPodCursor();						//trace("Membrane.doMouseMove()! hidePPod!");					}				}			}		}				private function showPPodCursor() {			if(!isPPodCursor){				p_engine.showCursor(Act.PSEUDOPOD);				isPPodCursor = true;				showTargetter();			}		}				private function hidePPodCursor() {			if (isPPodCursor) {				p_engine.endCursorArrow();				p_engine.lastCursor();				isPPodCursor = false;				hideTargetter();			}		}				private function doOver(e:Event) {			if (!isMouseDown) {				showCursor();			}		}				private function doOut(e:Event) {			if (!isMouseDown) {				hideCursor();			}		}				private function showCursor() {			if(!isMouseOver){				p_engine.showCursor(Act.PSEUDOPOD_PREPARE);				isMouseOver = true;			}		}				private function hideCursor() {			if (isMouseOver) {				p_engine.lastCursor();				isMouseOver = false;			}		}	}	}