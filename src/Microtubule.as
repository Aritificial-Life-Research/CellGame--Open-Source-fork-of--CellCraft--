package  {	import com.cheezeworld.math.Vector2D;	import com.pecLevel.EngineEvent;	import com.pecSound.SoundLibrary;	import fl.controls.List;	import fl.controls.NumericStepper;	import flash.display.DisplayObject;	import flash.display.Shape;	import flash.geom.Point;	import flash.events.Event;		/**	 * ...	 * @author Lars A. Doucet	 */	public class Microtubule extends CellObject	{		public var origin:Point;		public var terminus:Point;		public var finishPoint:Point;				private var distToTarget:Number;				public var p_obj:CellObject;				//private var speed:Number = 4;		private var xSpeed:Number = 0;		private var ySpeed:Number = 0;				private var angle:Number = 0;				public var xLoc:Number = 0;		public var yLoc:Number = 0;				private var counter:Number = 0;				public var amReady:Boolean = false;		public var hasCentrosome:Boolean = false; //is this the one with the centrosome?		public var isBlank:Boolean = false;				//public var list_bits:Vector.<TubeBit>;		//public var list_grav:Vector.<GravPoint>;		public var count_bit:int = 0;		//public var actinList:Vector.<ActinRoad>;				private var turnBit:int = 0;		private var delCounter:int = 0;		private var blurMax:int = 1;				private var blurringOn:Boolean = false;		public var isPpoding:Boolean = false;		public var isPpodContracting:Boolean = false;				private var actinTarget:DisplayObject;		private var currActin:int = 0;				public static var endTubeRadius:Number = 75;		private var debugShape:Shape;		public var debugging:Boolean = true;				public var p_skeleton:Cytoskeleton;		public var dirty_grav:Boolean = false; //do I have new grav data since last time I gave it?				public static var PPOD_R2:Number = 1000*1000;		public static var LENS_R2:Number = 1000*1000;				//public var isShrunk:Boolean = false;				private var instant_grow_count:int = 0;		private const INSTANT_GROW_FAILSAFE:int = 1000;				public function Microtubule() 		{			canSelect = false;			singleSelect = true;			//list_bits = new Vector.<TubeBit>;			//list_grav = new Vector.<GravPoint>;			finishPoint = new Point(0, 0);			cacheAsBitmap = true;			speed = 17;		}				public override function destruct() {			p_obj = null;			p_skeleton = null;			removeAllBits();			super.destruct();			origin = null;			terminus = null;			xLoc = 0;			yLoc = 0;		}				public function setPoints(o:Point,t:Point) {			origin = o;			terminus = t;			x = origin.x;			y = origin.y;		}				public function showDebugShape() {			debugShape = new Shape();			debugShape.graphics.clear();			var tb = getLastBit();			debugShape.graphics.moveTo(0, 0);			debugShape.graphics.lineStyle(2, 0xFFFFFF);			debugShape.graphics.drawCircle(tb.x, tb.y, endTubeRadius);			addChild(debugShape);		}				public function setSkeleton(c:Cytoskeleton) {			p_skeleton = c;		}		public function setObjectSelf() {			p_obj = this;			hasCentrosome = false;			isBlank = true;		}				public function setObject(c:CellObject) {			p_obj = c;			c.setTube(this);			if (c.getNumID() == Selectable.CENTROSOME) {				hasCentrosome = true;			}			isBlank = false;		}				public function getObject():CellObject {			return p_obj;		}				/*public function setTarget(t:DisplayObject) {			target1 = t;		}				public function setNextTarget(t:DisplayObject) {			target2 = t;		}*/				public function growActin(t:DisplayObject) {			//actinTarget = t;			//trace("GROW ACTIN!");			var p:Point = new Point(t.x, t.y);			makeActin(p);			//addEventListener(Event.ENTER_FRAME, growActinBit);		}				public function getTerminus():Point {			return terminus.clone();		}						public function getGravPoint():GravPoint {			if (isPpoding) {				return new GravPoint(new Point(xLoc, yLoc), this);			}else if (isPpodContracting) {				return new GravPoint(new Point(origin.x, origin.y), this);			}			return new GravPoint(new Point(xLoc, yLoc), p_obj);		}				public function getObj():CellObject {			return p_obj;		}				public function getGravPoints():Vector.<GravPoint> {			var list:Vector.<GravPoint> = new Vector.<GravPoint>;						//if(isPpoding)						list.push(new GravPoint(new Point(origin.x,origin.y),this));			list.push(new GravPoint(new Point(xLoc, yLoc),this));						return list;		}				public function lastX():Number {			return terminus.x;		}				public function lastY():Number {			return terminus.y;		}				public function getLastBit():TubeBit {			//return list_bits[list_bits.length - 1];			return null;		}				function makeActin(p:Point) {		/*	var temp:ActinRoad = new ActinRoad();			temp.setPoints(new Point(0,0), new Point(p.x - x, p.y - y));			temp.x = finishPoint.x - x;			temp.y = finishPoint.y - y;						var i:Number = (Math.random() * 2) - 1;			var randx:Number = (Math.random() * 10) * i;			var randy:Number = (Math.random() * 10) * i;				//var _p:Point = new Point((centrosome.x + p.x) / 2 + randx, (centrosome.y + p.y) / 2 + randy);									temp.grow();						addChild(temp);			actinList.push(temp);			//trace("actinList = " + actinList);			return temp;*/		}		public function followObj() {			/*trace("tube=(" + x + "," + y + ") obj=(" + p_obj.x + "," + p_obj.y + ")");			trace("skeleton=(" + p_skeleton.x + "," + p_skeleton.y + ")");*/			terminus = new Point(p_obj.x - p_skeleton.x, p_obj.y - p_skeleton.y);			calcTrajectory(terminus);			p_skeleton.updateGravityPoints();			//instantFollow();		}				public function instantGrow() {			xLoc = x;			yLoc = y;			calcTrajectory(terminus);			instantGrowBit();		}				public override function cancelMove() {			//trace("Microtubule.cancelMove()!");			removeEventListener(RunFrameEvent.RUNFRAME, growBit);			isMoving = false;			terminus.x = xLoc;			terminus.y = yLoc;			onFinish();		}				public function ppodTo(xx:Number, yy:Number) {			isPpoding = true;			p_skeleton.onStartPPod();			/*origin.x = terminus.x; //my old terminus is now my origin			origin.y = terminus.y; */			//trace("Microtubule.ppodTo(" + xx + "," + yy + ") origin=" + origin.x.toFixed(2) + "," + origin.y.toFixed(2) + " terminus=" + terminus.x.toFixed(2) + "," + terminus.y.toFixed(2) + " loc="+xLoc.toFixed(2)+","+yLoc.toFixed(2));			origin.x = terminus.x;			origin.y = terminus.y;			xLoc = terminus.x;			yLoc = terminus.y;			terminus.x = xx;			terminus.y = yy;			//trace("Microtubule.ppodTo(" + xx + "," + yy + "), NOW origin=" + origin.x.toFixed(2) + "," + origin.y.toFixed(2) + " terminus=" + terminus.x.toFixed(2) + "," + terminus.y.toFixed(2) + " loc="+xLoc.toFixed(2)+","+yLoc.toFixed(2));						calcTrajectory(terminus);			isMoving = true;			addEventListener(RunFrameEvent.RUNFRAME, growBit);		}				public function grow() {			xLoc = x;			yLoc = y;			calcTrajectory(terminus);			isMoving = true;			addEventListener(RunFrameEvent.RUNFRAME, growBit);		}				private function calcTrajectory(p:Point) {						var dist:Vector2D = new Vector2D(xLoc - p.x, yLoc - p.y);			dist.normalize();			angle = dist.toRotation();			angle *= (180 / Math.PI);			angle -= 90;						dist.multiply(speed);			xSpeed = -dist.x;			ySpeed = -dist.y;									/*distToTarget = distX * distX + distY * distY;			distToTarget = Math.sqrt(distToTarget);							distX = distX / distToTarget;			distY = distY / distToTarget;						angle = new Vector2D(distX, distY).toRotation();			angle *= (180 / Math.PI);			angle -= 90;*/			//trace("angle is = " + angle);						/*xSpeed = - distX * speed;			ySpeed = - distY * speed;*/		}				public override function doCellMove(xx:Number, yy:Number) {			terminus.x += xx;			terminus.y += yy;			xLoc += xx;			yLoc += yy;			origin.x += xx;			origin.y += yy;			//don't mess with your objects								}				public function ppodContract(xx:Number, yy:Number) {			//list_grav.pop();  //get rid of the last grav point			terminus.x -= xx; //move my endpoint			terminus.y -= yy;			xLoc -= xx;		  //move my currpoint			yLoc -= yy;			origin.x -= xx;   //move my startpoint			origin.y -= yy;			if(p_obj != this){ //if I have an associated object that is not me				/*	p_obj.x -= xx; //move it					p_obj.y -= yy;*/				//p_obj.getPpodContract(xx, yy);				if(p_obj.num_id == Selectable.CENTROSOME){					p_obj.getPpodContract(xx, yy);				}			}		}				private function contract() {						var tempX:Number = terminus.x;			var tempY:Number = terminus.y;			terminus.x = origin.x;			terminus.y = origin.y;			origin.x = tempX;			origin.y = tempY;			xLoc = origin.x;			yLoc = origin.y;			calcTrajectory(terminus);			//trace("Microtubule.contract! origin="+origin.x.toFixed(2)+","+origin.y.toFixed(2) + " terminus="+terminus.x.toFixed(2)+","+terminus.y.toFixed(2) + " loc="+xLoc.toFixed(2)+","+yLoc.toFixed(2));			addEventListener(RunFrameEvent.RUNFRAME, growBit);			//addEventListener(RunFrameEvent.RUNFRAME, contractBit);		}				private function instantFollow() {			countBits();			var bitsNeeded:Number = Math.ceil(distToTarget / speed);			var diff:int = bitsNeeded - count_bit;			if (diff < 0) { //we need less bits				removeBits(-diff);			}else if (diff > 0) {				addBits(diff);			}			reorientBits();		}				public function instantGrowBit() {			amReady = false;			//instant_grow_count = 0;			while (!amReady) {				/*instant_grow_count++;				if (instant_grow_count > INSTANT_GROW_FAILSAFE) {					amReady = true;				}*/				growBit(null);			}		}				private function addBits(i:int) {			for (var j:int = 0; j < i; j++){				//var temp:TubeBit = new TubeBit();				//list_bits.push(temp);				//addChild(temp);				count_bit++;			}		}				private function removeAllBits() {			/*var length:int = count_bit;			//var length:int = list_bits.length - 1;			for (var i:int = length; i >= 0; i--) {				//var temp:TubeBit = list_bits.pop();				//removeChild(temp);				count_bit--;			}			//list_bits = null;*/		}				private function removeBits(i:int) {			/*//trace("REMOVING " + i + "BITS!");			for(var j:int = 0; j < i; j++) {				//var temp:TubeBit = list_bits.pop();				//removeChild(temp);				count_bit--;			}*/		}				private function reorientBits() {			/*calcTrajectory(terminus);			xLoc = 0;			yLoc = 0;			for (var i:int = 0; i < count_bit; i++) {				//xLoc += xSpeed;				//yLoc += ySpeed;				//list_bits[i].x = xLoc - x;				//list_bits[i].y = yLoc - y;				//list_bits[i].rotation = angle;			}*/			//p_skeleton.updateGravityPoints();		}				public function cancelPPod() {			if (isPpoding) {				isPpoding = false;				removeEventListener(RunFrameEvent.RUNFRAME, growBit);				isMoving = false;				xSpeed = 0;				ySpeed = 0;				p_skeleton.onCancelPPod();				p_skeleton.removeTube(this, true);							}		}				private function onFinish() {			xSpeed = 0;			ySpeed = 0;			finishPoint.x = xLoc; //where our last bit was placed			finishPoint.y = yLoc; //			xLoc = terminus.x;	  //where we were trying to go			yLoc = terminus.y;						removeEventListener(RunFrameEvent.RUNFRAME, growBit);			isMoving = false;							amReady = true;			//list_grav.push(new GravPoint(new Point(xLoc, yLoc), this));						p_skeleton.finishTube(isBlank);				if (isPpoding) {				isPpoding = false;				p_skeleton.onFinishPPod();				Director.startSFX(SoundLibrary.SFX_MUD_STEP);				Director.startSFX(SoundLibrary.SFX_MUD_SLIDE);				isPpodContracting = true;				contract();			}else if (isPpodContracting) {				isPpodContracting = false;				//list_grav = null;				//trace("Microtubule.onFinish(), origin=" + origin.x.toFixed(2) + "," + origin.y.toFixed(2) + " terminus=" + terminus.x.toFixed(2) + "," + terminus.y.toFixed(2) + " loc="+xLoc.toFixed(2)+","+yLoc.toFixed(2));				//trace("Microtubule.onFinish() " + this.name);				p_skeleton.removeTube(this,true);			}		}				public function growBit(e:Event) {						var oldLocX:Number = xLoc;			var oldLocY:Number = yLoc;						xLoc += xSpeed;			yLoc += ySpeed;						var d2:Number = (xLoc * xLoc) + (yLoc * yLoc);			d2 += PPOD_R2*4;			var outside:Boolean = false;			if (d2 > BOUNDARY_R2) {				var cent_v:Vector2D = new Vector2D(cent_x - 0, cent_y - 0);				var cent_v_n:Vector2D = cent_v.getNormalized();				var dir_v:Vector2D = new Vector2D(terminus.x, terminus.y);				var dir_v_n:Vector2D = dir_v.getNormalized();				var angle:Number = dir_v.angleTo(cent_v);				trace("Microtubule.growBit OUTSIDE()! \n cent_v = " + cent_v + " dir_v = " + dir_v);				trace("Microtubule.growBit OUTSIDE()! \n cent_v_n = " + cent_v_n + " dir_v_n = " + dir_v_n);				outside = true;			}						if (outside) {//we're outside the boundary				xLoc = oldLocX;				yLoc = oldLocY;				if (isPpoding) {										//trace("Microtubule.growBit() FAIL boundary check! loc=(" + xLoc + "," + yLoc + ") bound_r2=" + BOUNDARY_R2 + " d2=" + d2);					cancelPPod();					//onFinish(); //force the ppod to end, because we're at the end of the thing					//end ppod				}				amReady=true; // This is a temp fix - should we keep it?			}else{					//we're inside the boundary				dirty_grav = true;								if (isPpodContracting) {					p_skeleton.ppodContract(this,xSpeed,ySpeed);				}								counter++;										if (counter*speed > 50) {					calcTrajectory(terminus);					counter = 0;				}							p_skeleton.updateTube();								if(terminus){					var absX:Number = (xLoc - terminus.x);					var absY:Number = (yLoc - terminus.y);					absX = absX < 0 ? -absX : absX;					absY = absY < 0 ? -absY : absY;										if ((absX < speed*1.5) && (absY < speed*1.5)) {						onFinish();					}					if (count_bit > 100) {						amReady = true;						//trace("Microtubule.growBit() : too many bits!");						throw new Error("Microtubule.growBit(): WAAAAY TOO MANY BITS!");					}				}else {					//trace("Microtubule.growBit() : no terminus!");'					amReady = true;				}			}		}				public function startDecay() {			/*var r:int = Game.decayRule;			if (r == 1) {				delCounter = bitList.length-1;				addEventListener(Event.ENTER_FRAME, deleteBackBits);			}*/		}								public function getTubePoint(i:int):Point {			var p:Point = new Point(0,0);			//p.x = list_bits[i].x;			//p.y = list_bits[i].y;			return p;		}				private function countBits() {			//count_bit = list_bits.length;		}				private function getBitCount():int {			return count_bit;		}				public function deleteBackBits(e:Event) {			/*if(delCounter > 0){				//removeChild(list_bits[delCounter]);				//list_bits[delCounter] = null;				count_bit--;				delCounter--;			}else {				removeEventListener(RunFrameEvent.RUNFRAME, deleteBackBits);				p_skeleton.removeTube(this);			}*/		}			}	}